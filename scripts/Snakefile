import sys

from os import listdir
from os.path import isfile, join, abspath

from snakemake.utils import min_version

min_version("3.4.2")

REF = config["ref_fa"]
REF_GTF = config["ref_gtf"]
NAME = config["name"]
OUT_DIR = config["out_dir"]
OUT_DIR_FULL = os.path.abspath(config["out_dir"])
MIN_INTRON = config["min_intron"]
MAX_INTRON = config["max_intron"]
STRANDEDNESS = config["strandedness"]
THREADS = config["threads"]
READ_LENGTH = config["read_length"]

LOAD_TOPHAT = config["load_tophat"]
LOAD_GMAP = config["load_gsnap"]
LOAD_STAR = config["load_star"]
LOAD_HISAT = config["load_hisat"]
LOAD_SAMTOOLS = config["load_samtools"]
LOAD_CUFFLINKS = config["load_cufflinks"]
LOAD_STRINGTIE = config["load_stringtie"]
LOAD_PORTCULLIS = config["load_portcullis"]
LOAD_SPANKI = config["load_spanki"]
LOAD_FINESPLICE = config["load_finesplice"]

INDEX_STAR_EXTRA = config["index_star_extra"]
ALIGN_TOPHAT_EXTRA = config["align_tophat_extra"]
ALIGN_GSNAP_EXTRA = config["align_gsnap_extra"]
ALIGN_STAR_EXTRA = config["align_star_extra"]
ASM_CUFFLINKS_EXTRA = config["asm_cufflinks_extra"]
ASM_STRINGTIE_EXTRA = config["asm_stringtie_extra"]
JUNC_PORTCULLIS_PREP_EXTRA = config["junc_portcullis_prep_extra"]
JUNC_PORTCULLIS_JUNC_EXTRA = config["junc_portcullis_junc_extra"]
JUNC_PORTCULLIS_FILTER_EXTRA = config["junc_portcullis_filter_extra"]
JUNC_SPANKI_EXTRA = config["junc_spanki_extra"]
JUNC_FINESPLICE_EXTRA = config["junc_finesplice_extra"]

INPUT_SETS = config["input_sets"]
ALIGNMENT_METHODS = config["align_methods"]
ASSEMBLY_METHODS = config["asm_methods"]
JUNC_METHODS = config["junc_methods"]

#Shortcuts
READS_DIR = OUT_DIR + "/reads"
READS_DIR_FULL = os.path.abspath(READS_DIR)
SIM_DIR = READS_DIR + "/sim"
SIM_DIR_FULL = os.path.abspath(SIM_DIR)
ALIGN_DIR = OUT_DIR + "/alignments"
ALIGN_DIR_FULL = os.path.abspath(ALIGN_DIR)
ASM_DIR = OUT_DIR + "/assemblies"
ASM_DIR_FULL = os.path.abspath(ASM_DIR)
JUNC_DIR = OUT_DIR + "/junctions"
JUNC_DIR_FULL = os.path.abspath(JUNC_DIR)

CWD = os.getcwd()


TRINITY_STRAND = "--SS_lib_type=RF" if STRANDEDNESS == "fr-firststrand" else "--SS_lib_type=FR" if STRANDEDNESS == "fr-secondstrand" else ""
HISAT_STRAND = "--rna-strandness=RF" if STRANDEDNESS == "fr-firststrand" else "--rna-strandness=FR" if STRANDEDNESS == "fr-secondstrand" else "F"
PORTCULLIS_STRAND = "firststrand" if STRANDEDNESS == "fr-firststrand" else "secondstrand" if STRANDEDNESS == "fr-secondstrand" else "unstranded"


#########################
Rules

# Define 
rule all:
	input: 
		expand(ASM_DIR + "/output/{asm_method}-{align_method}-{sample}.gtf", align_method=ALIGNMENT_METHODS, asm_method=ASSEMBLY_METHODS, sample=INPUT_SETS),
		expand(JUNC_DIR + "/output/{junc_method}-{align_method}-{sample}.bed", junc_method=JUNC_METHODS, align_method=ALIGNMENT_METHODS, sample=INPUT_SETS)
		

#rule clean:
#	shell: "rm -rf {out}"


rule clean_reads:
	input: 
		r1=R1,
		r2=R2
	output:
		r1=READS_DIR_FULL+"/trim/r1_val_1.fq",
		r2=READS_DIR_FULL+"/trim/r2_val_2.fq",
		linkr1=READS_DIR+"/real.R1.fq",
		linkr2=READS_DIR+"/real.R2.fq"
	params:
		outdir=READS_DIR+"/trim"
	log: READS_DIR+"/trim.log"		
	shell: "{LOAD_TRIMGALORE}; trim_galore --paired --length {READ_LENGTH} -o {params.outdir} {input.r1} {input.r2} > {log} 2>&1 && ln -sf {output.r1} {output.linkr1} && ln -sf {output.r2} {output.linkr2} && touch -h {output.linkr1} {output.linkr2}"



rule simgen_bowtie_index:
	input:
		REF
	output: 
		SIM_DIR+"/bowtie_index/"+REF+".1.ebwt"
	params: outdir=SIM_DIR+"/bowtie_index"
	log:
		SIM_DIR+"/bowtie.index.log"
	threads: 1
	message: "Creating bowtie index of genome"
	shell: "{LOAD_BOWTIE}; bowtie-build {input} {params.outdir}"

rule simgen_bowtie_align:
	input:
		r1=READS_DIR+"/{sample}.R1.fq",
                r2=READS_DIR+"/{sample}.R2.fq",
                index=rules.align_tophat_index.output
	output:
		map=SIM_DIR+"/bowtie/bowtie.map"
	params: indexdir=SIM_DIR+"/bowtie_index"
	log: SIM_DIR+"/bowtie.align.log"
		
	threads: int(THREADS)
	shell: "{LOAD_BOWTIE}; bowtie -p {threads} --chunkmbs 1000 -X 500 {params.indexdir} -1 {input.r1} -2 {input.r2} > {output.map} 2> {log}"
	


rule simgen_model:
	input:
		map=rules.simgen_bowtie_align.output.map
	output: SIM_DIR+"/model/logfile.txt"
	params: outdir=SIM_DIR+"/model"
	log: SIM_DIR+"/spanki_model.log"
	threads: 1
	shell: "{LOAD_SPANKI}; spankisim_models -i {input.map} -e 2 -l {READ_LENGTH} -o {params.outdir} > {log} 2&>1"


rule simgen_reads:
	input:
		gtf=REF_GTF
                fa=REF
	output: 
		r1=SIM_DIR_FULL+"/reads/sim_1.fastq"
		r2=SIM_DIR_FULL+"/reads/sim_2.fastq"
		bam=SIM_DIR_FULL+"/reads/sim.bam"
		linkr1=READS_DIR+"/sim.R1.fq"
		linkr2=READS_DIR+"/sim.R2.fq"
		linkbam=ALIGN_DIR+"/output/sim.bam"
	params: outdir=SIM_DIR+"/reads"
	log: SIM_DIR+"/spanki_readgen.log"
	threads: 1	
	shell: "{LOAD_SPANKI}; spankisim_transcripts -g {input.gtf} -f {input.ref} -o {params.outdir} -cov 30 -bp {READ_LENGTH} -ends 2 -frag 250 > {log} 2&>1 && ln -sf {output.r1} {output.linkr1} && ln -sf {output.r2} {output.linkr2} && ln -sf {output.bam} {output.linkbam} && touch -h {output.linkr1} {output.linkr2} {output.linkbam}"
	



rule align_tophat_index:
        input: REF 
        output: ALIGN_DIR +"/tophat/index/"+NAME+".4.bt2"
        log: ALIGN_DIR + "/tophat.index.log"
        threads: 1
        message: "Indexing genome with tophat"
        shell: "{LOAD_TOPHAT}; bowtie2-build {REF} {ALIGN_DIR}/tophat/index/{NAME} > {log} 2>&1"


rule align_tophat:
        input:
                r1=READS_DIR+"/{sample}.R1.fq",
                r2=READS_DIR+"/{sample}.R2.fq",
                index=rules.align_tophat_index.output
        output:
                bam=ALIGN_DIR_FULL+"/tophat/{sample}/accepted_hits.bam",
                link=ALIGN_DIR+"/output/tophat-{sample}.bam"
        params: 
                outdir=ALIGN_DIR+"/tophat/{sample}",
                indexdir=ALIGN_DIR+"/tophat/index/"+NAME
        log: ALIGN_DIR + "/tophat-{sample}.log"
        threads: int(THREADS)
        message: "Aligning RNAseq data with tophat: {input.r1}; {input.r2}"
        shell: "{LOAD_TOPHAT}; tophat2 --output-dir={params.outdir} --num-threads={threads} --min-intron-length={MIN_INTRON} --max-intron-length={MAX_INTRON} --microexon-search --library-type={STRANDEDNESS} {ALIGN_TOPHAT_EXTRA} {params.indexdir} {input.r1} {input.r2} > {log} 2>&1 && ln -sf {output.bam} {output.link} && touch -h {output.link}"


rule align_tophat_wref:
	input:
		r1=READS_DIR+"/real.R1.fq",
		r2=READS_DIR+"/real.R2.fq",
		index=rules.align_tophat_index.output,
		gtf=REF_GTF
        output:
                bed=ALIGN_DIR_FULL+"/tophat/gold/junctions.bed",
                link=ALIGN_DIR+"/output/gold/tophat.bed"
        params: 
                outdir=ALIGN_DIR+"/tophat/gold",
                indexdir=ALIGN_DIR+"/tophat/index/"+NAME
        log: ALIGN_DIR + "/tophat-{sample}.log"
        threads: int(THREADS)
        message: "Aligning RNAseq data with tophat using GTF reference: {input.r1}; {input.r2}"
        shell: "{LOAD_TOPHAT}; tophat2 --output-dir={params.outdir} --num-threads={threads} --min-intron-length={MIN_INTRON} --max-intron-length={MAX_INTRON} --microexon-search --library-type={STRANDEDNESS} --GTF={input.gtf} {ALIGN_TOPHAT_EXTRA} {params.indexdir} {input.r1} {input.r2} > {log} 2>&1 && ln -sf {output.bed} {output.link} && touch -h {output.link}"


rule align_gsnap_index:
        input: REF
        output: ALIGN_DIR +"/gsnap/index/"+NAME+"/"+NAME+".sachildguide1024"
        log: ALIGN_DIR +"/gsnap.index.log"
        threads: 1
        message: "Indexing genome with gsnap"
        shell: "{LOAD_GMAP}; gmap_build --dir={ALIGN_DIR}/gsnap/index --db={NAME} {input} > {log} 2>&1"


rule align_gsnap:
        input:
                r1=READS_DIR+"/{sample}.R1.fq",
                r2=READS_DIR+"/{sample}.R2.fq",
                index=rules.align_gsnap_index.output
        output:
                bam=ALIGN_DIR_FULL+"/gsnap/{sample}/gsnap.bam",
                link=ALIGN_DIR+"/output/gsnap-{sample}.bam"
        log: ALIGN_DIR+"/gsnap-{sample}.log"
        threads: int(THREADS)
        message: "Aligning RNAseq with gsnap: {input.r1}; {input.r2}"
        shell: "{LOAD_GMAP}; {LOAD_SAMTOOLS}; gsnap --dir={ALIGN_DIR}/gsnap/index --db={NAME} {ALIGN_GSNAP_EXTRA} --novelsplicing=1 --localsplicedist={MAX_INTRON} --nthreads={threads} --format=sam --npaths=20 {input.r1} {input.r2} 2> {log} | samtools view -b -@ {threads} - > {output.bam} && ln -sf {output.bam} {output.link} && touch -h {output.link}"



rule align_star_index:
        input: os.path.abspath(REF)
        output: ALIGN_DIR +"/star/index/SAindex"
        params: indexdir=ALIGN_DIR_FULL+"/star/index"
        log: ALIGN_DIR_FULL+"/star.index.log"
        threads: int(THREADS)
        message: "Indexing genome with star"
        shell: "{LOAD_STAR}; cd {ALIGN_DIR_FULL}/star; STAR --runThreadN {threads} --runMode genomeGenerate --genomeDir {params.indexdir} --genomeFastaFiles {input} {INDEX_STAR_EXTRA} > {log} 2>&1; cd {CWD}"

rule align_star_index_wref:
        input: 
		fa=os.path.abspath(REF)
		gtf=os.path.abspath(REF_GTF)
	
        output: ALIGN_DIR +"/star/index_wref/SAindex"
        params: indexdir=ALIGN_DIR_FULL+"/star/index_wref"
        log: ALIGN_DIR_FULL+"/star.index_wref.log"
        threads: int(THREADS)
        message: "Indexing genome with star using GTF reference"
        shell: "{LOAD_STAR}; cd {ALIGN_DIR_FULL}/star; STAR --runThreadN {threads} --runMode genomeGenerate --genomeDir {params.indexdir} --genomeFastaFiles {input.fa} --sjdbGTFfile {input.gtf} --sjdbOverhang {READ_LENGTH - 1} {INDEX_STAR_EXTRA} > {log} 2>&1; cd {CWD}"


rule align_star:
        input:
                r1=READS_DIR_FULL+"/{sample}.R1.fq",
                r2=READS_DIR_FULL+"/{sample}.R2.fq",
                index=rules.align_star_index.output
        output:
                bam=ALIGN_DIR_FULL+"/star/{sample}/Aligned.out.bam",
                link=ALIGN_DIR+"/output/star-{sample}.bam"
        params:
                outdir=ALIGN_DIR_FULL+"/star/{sample}",
                indexdir=ALIGN_DIR_FULL+"/star/index"
        log: ALIGN_DIR_FULL+"/star-{sample}.log"
        threads: int(THREADS)
        message: "Aligning input with star"
        shell: "{LOAD_STAR}; cd {params.outdir}; STAR --runThreadN {threads} --runMode alignReads --genomeDir {params.indexdir} --readFilesIn {input.r1} {input.r2} --outSAMtype BAM Unsorted --outSAMstrandField intronMotif --alignIntronMin {MIN_INTRON} --alignIntronMax {MAX_INTRON} --alignMatesGapMax 20000 --outFileNamePrefix {params.outdir}/ {ALIGN_STAR_EXTRA} > {log} 2>&1; cd {CWD}; ln -sf {output.bam} {output.link} && touch -h {output.link}"

rule align_star_wref:
        input:
                r1=READS_DIR_FULL+"/real.R1.fq",
                r2=READS_DIR_FULL+"/real.R2.fq",
                index=rules.align_star_index_wref.output
        output:
                tab=ALIGN_DIR+"/star/gold/SJ.out.tab",
                bed=ALIGN_DIR+"/output/gold/star.bed"
        params:
                outdir=ALIGN_DIR_FULL+"/star/{sample}",
                indexdir=ALIGN_DIR_FULL+"/star/index"
        log: ALIGN_DIR_FULL+"/star-{sample}.log"
        threads: int(THREADS)
        message: "Aligning input with star"
        shell: "{LOAD_STAR}; cd {params.outdir}; STAR --runThreadN {threads} --runMode alignReads --genomeDir {params.indexdir} --readFilesIn {input.r1} {input.r2} --outSAMtype BAM Unsorted --outSAMstrandField intronMotif --alignIntronMin {MIN_INTRON} --alignIntronMax {MAX_INTRON} --alignMatesGapMax 20000 --outFileNamePrefix {params.outdir}/ {ALIGN_STAR_EXTRA} > {log} 2>&1; cd {CWD}; {LOAD_PORTCULLIS}; star_tab2bed {output.tab} > {output.bed}"


rule align_hisat_index:
	input: REF
	output: ALIGN_DIR+"/hisat/index/"+NAME+".4.ht2"
	log: ALIGN_DIR+"/hisat.index.log"
	threads: 1
	message: "Indexing genome with hisat"
	shell: "{LOAD_HISAT}; hisat2-build {input} {ALIGN_DIR}/hisat/index/{NAME} > {log} 2>&1"


rule align_hisat:
	input: 
		r1=READS_DIR+"/{sample}.R1.fq",
		r2=READS_DIR+"/{sample}.R2.fq",
		index=rules.align_hisat_index.output
	output:
		bam=ALIGN_DIR_FULL+"/hisat/{sample}/hisat.bam",
		link=ALIGN_DIR+"/output/hisat-{sample}.bam"
	params:
		indexdir=ALIGN_DIR+"/hisat/index/"+NAME
	log: ALIGN_DIR+"/hisat-{sample}.log"
        threads: int(THREADS)
        message: "Aligning input with hisat"
	shell: "{LOAD_HISAT}; {LOAD_SAMTOOLS}; hisat2 -p {threads} --min-intronlen={MIN_INTRON} --max-intronlen={MAX_INTRON} {HISAT_STRAND} -x {params.indexdir} -1 {input.r1} -2 {input.r2} 2> {log} | samtools view -b -@ {threads} - > {output.bam}; ln -sf {output.bam} {output.link} && touch -h {output.link}"



rule bam_sort:
	input: ALIGN_DIR+"/output/{align_method}-{sample}.bam"
	output: ALIGN_DIR+"/output/{align_method}-{sample}.sorted.bam"
	threads: int(THREADS)
	message: "Using samtools to sort {input}"
	shell: "{LOAD_SAMTOOLS}; samtools sort -o {output} -O bam -m 1G -T sort_{wildcards.align_method}_{wildcards.sample} -@ {threads} {input}"

rule bam_index:
	input: rules.bam_sort.output
	output: ALIGN_DIR+"/output/{align_method}-{sample}.sorted.bam.bai"
	threads: 1
	message: "Using samtools to index: {input}"
	shell: "{LOAD_SAMTOOLS}; samtools index {input}"


rule asm_cufflinks:
        input:
                bam=rules.bam_sort.output,
                ref=REF
        output:
                gtf=ASM_DIR_FULL+"/cufflinks-{align_method}-{sample}/transcripts.gtf",
                link=ASM_DIR+"/output/cufflinks-{align_method}-{sample}.gtf"
        params: outdir=ASM_DIR+"/cufflinks-{align_method}-{sample}"
        log: ASM_DIR+"/cufflinks-{align_method}-{sample}.log"
        threads: int(THREADS)
        message: "Using cufflinks to assemble: {input.bam}"
        shell: "{LOAD_CUFFLINKS}; cufflinks --output-dir={params.outdir} --num-threads={threads} --library-type={STRANDEDNESS} --min-intron-length={MIN_INTRON} --max-intron-length={MAX_INTRON} --no-update-check {ASM_CUFFLINKS_EXTRA} {input.bam} > {log} 2>&1 && ln -sf {output.gtf} {output.link} && touch -h {output.link}"




rule asm_stringtie:
        input: 
                bam=rules.bam_sort.output,
                ref={REF}
        output: 
                gtf=ASM_DIR_FULL+"/stringtie-{align_method}-{sample}/stringtie-{align_method}-{sample}.gtf",
                link=ASM_DIR+"/output/stringtie-{align_method}-{sample}.gtf"
        log: ASM_DIR+"/stringtie-{align_method}-{sample}.log"
        threads: int(THREADS)
        message: "Using stringtie to assemble: {input.bam}"
        shell: "{LOAD_STRINGTIE}; stringtie {input.bam} -l Stringtie_{wildcards.align_method}_{wildcards.sample} -f 0.05 -m 200 {ASM_STRINGTIE_EXTRA} -o {output.gtf} -p {threads} > {log} 2>&1 && ln -sf {output.gtf} {output.link} && touch -h {output.link}"


rule portcullis_prep:
        input:
                ref={REF},
                bam=rules.bam_sort.output
        output: JUNC_DIR+"/portcullis/{align_method}-{sample}-prep/portcullis.sorted.alignments.bam.bai"
        params: outdir=JUNC_DIR+"/portcullis/{align_method}-{sample}-prep"
        log: JUNC_DIR+"/portcullis/{align_method}-{sample}-prep.log"
        threads: int(THREADS)
        message: "Using portcullis to prepare: {input}"
        shell: "{LOAD_PORTCULLIS}; portcullis prep -o {params.outdir} -l -s {PORTCULLIS_STRAND} -t {threads} {input.ref} {input.bam} > {log} 2>&1"


rule portcullis_junc:
        input:
                bai=rules.portcullis_prep.output
        output: JUNC_DIR+"/portcullis/{align_method}-{sample}-junc/{align_method}-{sample}.junctions.tab"
        params:
                prepdir=JUNC_DIR+"/portcullis/{align_method}-{sample}-prep",
                outdir=JUNC_DIR+"/portcullis/{align_method}-{sample}-junc"
        log: JUNC_DIR+"/portcullis/{align_method}-{sample}-junc.log"
        threads: int(THREADS)
        message: "Using portcullis to analyse potential junctions: {input}"
        shell: "{LOAD_PORTCULLIS}; portcullis junc -o {params.outdir} -p {wildcards.align_method}-{wildcards.sample} -t {threads} {params.prepdir} > {log} 2>&1"

rule portcullis_filter:
        input: rules.portcullis_junc.output
        output:
                link=JUNC_DIR+"/output/portcullis-{align_method}-{sample}.bed"
	params: 
		outdir=JUNC_DIR+"/portcullis/{align_method}-{sample}-filtered",
                bed=JUNC_DIR_FULL+"/portcullis/{align_method}-{sample}-filtered/{align_method}-{sample}.pass.junctions.bed"
	log: JUNC_DIR+"/portcullis/{align_method}-{sample}-filter.log"
        threads: 1
        message: "Using portcullis to filter invalid junctions: {input}"
        shell: "{LOAD_PORTCULLIS}; portcullis filter -o {params.outdir} -p {wildcards.align_method}-{wildcards.sample} {input} > {log} 2>&1 && ln -sf {params.bed} {output.link} && touch -h {output.link}"




# SPANKI will only run with tophat BAMs.  So I've implemented some code to ensure the output file exists regardless.
rule spanki:
	input: 
		bam=rules.bam_sort.output,
                ref_fa=os.path.abspath(REF),
		ref_gtf=os.path.abspath(REF_GTF)
	output:
		link=JUNC_DIR+"/output/spanki-{align_method}-{sample}.bed"
	params: 
		bam_full=ALIGN_DIR_FULL+"/output/{align_method}-{sample}.sorted.bam",
		spankidir=JUNC_DIR_FULL+"/spanki/{align_method}-{sample}",
		all=JUNC_DIR+"/spanki/{align_method}-{sample}/junctions_out/juncs.all",
		filtered=JUNC_DIR+"/spanki/{align_method}-{sample}/junctions_out/juncs.filtered",
		bed=JUNC_DIR_FULL+"/spanki/{align_method}-{sample}/junctions_out/juncs.bed",
	log: JUNC_DIR_FULL+"/spanki/spanki-{align_method}-{sample}.log"
	threads: 1
	message: "Using spanki to filter junctions: {input.bam}"
	shell: "{LOAD_SPANKI}; cd {params.spankidir}; spankijunc -i {params.bam_full} -g {input.ref_gtf} -f {input.ref_fa} > {log} 2>&1 && cd {CWD} && {LOAD_PORTCULLIS} && spanki_filter.py {params.all} > {params.filtered} && spanki2bed.py {params.filtered} > {params.bed} && ln -sf {params.bed} {output.link} && touch -h {output.link}  || (echo \"SPANKI failed. This is expected for non-tophat BAMs.  See log for details: {log}\";  touch {output.link})"



# Finesplice will only run with tophat BAMs as it requires the NH attribute.  So I've implemented some code to ensure the output file exists regardless.
rule finesplice:
	input: 
		bam=rules.bam_sort.output
	output: 
		link=JUNC_DIR+"/output/finesplice-{align_method}-{sample}.bed"
	params: 
		bam_full=ALIGN_DIR_FULL+"/output/{align_method}-{sample}.sorted.bam",
		fsdir=JUNC_DIR_FULL+"/finesplice/{align_method}-{sample}",
		junc=JUNC_DIR+"/finesplice/{align_method}-{sample}/{align_method}-{sample}.sorted.accepted.junc",
		bed=JUNC_DIR_FULL+"/finesplice/{align_method}-{sample}/finesplice.bed",
	log: JUNC_DIR_FULL+"/finesplice/finesplice-{align_method}-{sample}.log"
	message: "Using finesplice to filter junctions: {input.bam}"
	shell: "{LOAD_FINESPLICE}; cd {params.fsdir}; FineSplice.py -i {params.bam_full} -l {READ_LENGTH} > {log} 2>&1 && cd {CWD} && {LOAD_PORTCULLIS} && fs2bed {params.junc} > {params.bed} && ln -sf {params.bed} {output.link} && touch -h {output.link} || (echo \"Finesplice failed. This is expected for non-tophat BAMs.  See log for details: {log}\"; touch {output.link})"

