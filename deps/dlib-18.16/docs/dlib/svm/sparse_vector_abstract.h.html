<html><!-- Created using the cpp_pretty_printer from the dlib C++ library.  See http://dlib.net for updates. --><head><title>dlib C++ Library - sparse_vector_abstract.h</title></head><body bgcolor='white'><pre>
<font color='#009900'>// Copyright (C) 2009  Davis E. King (davis@dlib.net)
</font><font color='#009900'>// License: Boost Software License   See LICENSE.txt for the full license.
</font><font color='#0000FF'>#undef</font> DLIB_SVm_SPARSE_VECTOR_ABSTRACT_
<font color='#0000FF'>#ifdef</font> DLIB_SVm_SPARSE_VECTOR_ABSTRACT_

<font color='#0000FF'>#include</font> <font color='#5555FF'>&lt;</font>cmath<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>#include</font> "<a style='text-decoration:none' href='../algs.h.html'>../algs.h</a>"
<font color='#0000FF'>#include</font> "<a style='text-decoration:none' href='../serialize.h.html'>../serialize.h</a>"
<font color='#0000FF'>#include</font> "<a style='text-decoration:none' href='../matrix.h.html'>../matrix.h</a>"
<font color='#0000FF'>#include</font> <font color='#5555FF'>&lt;</font>map<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>#include</font> <font color='#5555FF'>&lt;</font>vector<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>#include</font> "<a style='text-decoration:none' href='../graph_utils/sample_pair_abstract.h.html'>../graph_utils/sample_pair_abstract.h</a>"
<font color='#0000FF'>#include</font> "<a style='text-decoration:none' href='../graph_utils/ordered_sample_pair_abstract.h.html'>../graph_utils/ordered_sample_pair_abstract.h</a>"

<font color='#0000FF'>namespace</font> dlib
<b>{</b>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <a name='sparse_vectors'/><font color='#009900'>/*!A sparse_vectors

        In dlib, sparse vectors are represented using the container objects
        in the C++ STL.  In particular, a sparse vector is any container that 
        contains a range of std::pair&lt;key, scalar_value&gt; objects where:
            - key is an unsigned integral type 
            - scalar_value is float, double, or long double
            - the std::pair objects have unique key values
            - the std::pair objects are sorted such that small keys come first 

        Therefore, if an object satisfies the above requirements we call it a
        "sparse vector".  Additionally, we define the concept of an "unsorted sparse vector"
        to be a sparse vector that doesn't necessarily have sorted or unique key values.  
        Therefore, all sparse vectors are valid unsorted sparse vectors but not the other 
        way around.  

        An unsorted sparse vector with duplicate keys is always interpreted as
        a vector where each dimension contains the sum of all corresponding elements 
        of the unsorted sparse vector.  For example, an unsorted sparse vector 
        with the elements { (3,1), (0, 4), (3,5) } represents the 4D vector:
            [4, 0, 0, 1+5]



        Examples of valid sparse vectors are:    
            - std::map&lt;unsigned long, double&gt;
            - std::vector&lt;std::pair&lt;unsigned long, float&gt; &gt; where the vector is sorted.
              (you could make sure it was sorted by applying std::sort to it)


        Finally, by "dense vector" we mean a dlib::matrix object which represents
        either a row or column vector.

        The rest of this file defines a number of helper functions for doing normal 
        vector arithmetic things with sparse vectors.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <a name='has_unsigned_keys'/><font color='#009900'>/*!A has_unsigned_keys

        This is a template where has_unsigned_keys&lt;T&gt;::value == true when T is a
        sparse vector that contains unsigned integral keys and false otherwise.
    !*/</font>

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>struct</font> <b><a name='has_unsigned_keys'></a>has_unsigned_keys</b>
    <b>{</b>
        <font color='#0000FF'>static</font> <font color='#0000FF'>const</font> <font color='#0000FF'><u>bool</u></font> value <font color='#5555FF'>=</font> is_unsigned_type<font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T::value_type::first_type<font color='#5555FF'>&gt;</font>::value;
    <b>}</b>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'>typename</font> U<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>typename</font> T::value_type::second_type <b><a name='distance_squared'></a>distance_squared</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> a,
        <font color='#0000FF'>const</font> U<font color='#5555FF'>&amp;</font> b
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - a and b are sparse vectors
        ensures
            - returns the squared distance between the vectors
              a and b
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'>typename</font> U, <font color='#0000FF'>typename</font> V, <font color='#0000FF'>typename</font> W<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>typename</font> T::value_type::second_type <b><a name='distance_squared'></a>distance_squared</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> V<font color='#5555FF'>&amp;</font> a_scale,
        <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> a,
        <font color='#0000FF'>const</font> W<font color='#5555FF'>&amp;</font> b_scale,
        <font color='#0000FF'>const</font> U<font color='#5555FF'>&amp;</font> b
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - a and b are sparse vectors
        ensures
            - returns the squared distance between the vectors
              a_scale*a and b_scale*b
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'>typename</font> U<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>typename</font> T::value_type::second_type <b><a name='distance'></a>distance</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> a,
        <font color='#0000FF'>const</font> U<font color='#5555FF'>&amp;</font> b
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - a and b are sparse vectors
        ensures
            - returns the distance between the vectors
              a and b.  (i.e. std::sqrt(distance_squared(a,b)))
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'>typename</font> U, <font color='#0000FF'>typename</font> V, <font color='#0000FF'>typename</font> W<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>typename</font> T::value_type::second_type <b><a name='distance'></a>distance</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> V<font color='#5555FF'>&amp;</font> a_scale,
        <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> a,
        <font color='#0000FF'>const</font> W<font color='#5555FF'>&amp;</font> b_scale,
        <font color='#0000FF'>const</font> U<font color='#5555FF'>&amp;</font> b
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - a and b are sparse vectors
        ensures
            - returns the distance between the vectors
              a_scale*a and b_scale*b.  (i.e. std::sqrt(distance_squared(a_scale,a,b_scale,b)))
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'>typename</font> U<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'><u>void</u></font> <b><a name='assign'></a>assign</b> <font face='Lucida Console'>(</font>
        T<font color='#5555FF'>&amp;</font> dest,
        <font color='#0000FF'>const</font> U<font color='#5555FF'>&amp;</font> src
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - dest == a sparse vector or a dense vector
            - src == a sparse vector or a dense vector
            - dest is not dense when src is sparse
              (i.e. you can't assign a sparse vector to a dense vector.  This is
              because we don't know what the proper dimensionality should be for the
              dense vector)
        ensures
            - #src represents the same vector as dest.  
              (conversion between sparse/dense formats is done automatically)
    !*/</font>


<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>typename</font> T::value_type::second_type <b><a name='dot'></a>dot</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> a,
        <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> b
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - a and b are sparse vectors 
        ensures
            - returns the dot product between the vectors a and b
    !*/</font>

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T1, <font color='#0000FF'>typename</font> T2, <font color='#0000FF'>typename</font> T3, <font color='#0000FF'>typename</font> T4, <font color='#0000FF'>typename</font> T5, <font color='#0000FF'>typename</font> T6<font color='#5555FF'>&gt;</font>
    T4 <b><a name='dot'></a>dot</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> std::vector<font color='#5555FF'>&lt;</font>T1,T2<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> a,
        <font color='#0000FF'>const</font> std::map<font color='#5555FF'>&lt;</font>T3,T4,T5,T6<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> b
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - a and b are sparse vectors 
        ensures
            - returns the dot product between the vectors a and b
    !*/</font>

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T1, <font color='#0000FF'>typename</font> T2, <font color='#0000FF'>typename</font> T3, <font color='#0000FF'>typename</font> T4, <font color='#0000FF'>typename</font> T5, <font color='#0000FF'>typename</font> T6<font color='#5555FF'>&gt;</font>
    T4 <b><a name='dot'></a>dot</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> std::map<font color='#5555FF'>&lt;</font>T3,T4,T5,T6<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> a,
        <font color='#0000FF'>const</font> std::vector<font color='#5555FF'>&lt;</font>T1,T2<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> b
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - a and b are sparse vectors 
        ensures
            - returns the dot product between the vectors a and b
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'>typename</font> EXP<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>typename</font> T::value_type::second_type <b><a name='dot'></a>dot</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> a,
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&lt;</font>EXP<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> b
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - a is an unsorted sparse vector
            - is_vector(b) == true
        ensures
            - returns the dot product between the vectors a and b.  
            - if (max_index_plus_one(a) &gt;= b.size()) then
                - a's dimensionality is greater than b's dimensionality.  In this case we
                  pretend b is padded by as many zeros as is needed to make the dot product
                  work.  So this means that any elements in a that go beyond the length of
                  b are simply ignored.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'>typename</font> EXP<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>typename</font> T::value_type::second_type <b><a name='dot'></a>dot</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&lt;</font>EXP<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> a,
        <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> b
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - b is an unsorted sparse vector
            - is_vector(a) == true
        ensures
            - returns the dot product between the vectors a and b
            - if (max_index_plus_one(b) &gt;= a.size()) then
                - b's dimensionality is greater than a's dimensionality.  In this case we
                  pretend a is padded by as many zeros as is needed to make the dot product
                  work.  So this means that any elements in b that go beyond the length of
                  a are simply ignored.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>typename</font> T::value_type::second_type <b><a name='length_squared'></a>length_squared</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> a
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - a is a sparse vector
        ensures
            - returns dot(a,a) 
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>typename</font> T::value_type::second_type <b><a name='length'></a>length</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> a
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - a is a sparse vector
        ensures
            - returns std::sqrt(length_squared(a,a))
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'>typename</font> U<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'><u>void</u></font> <b><a name='scale_by'></a>scale_by</b> <font face='Lucida Console'>(</font>
        T<font color='#5555FF'>&amp;</font> a,
        <font color='#0000FF'>const</font> U<font color='#5555FF'>&amp;</font> value
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - a is an unsorted sparse vector or a dlib::matrix
        ensures
            - #a == a*value
              (i.e. multiplies every element of the vector a by value)
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font>
    T <b><a name='add'></a>add</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> a,
        <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> b
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - a is a sparse vector or dlib::matrix
            - b is a sparse vector or dlib::matrix
        ensures
            - returns a vector or matrix which represents a+b.  If the inputs are
              sparse vectors then the result is a sparse vector.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font>
    T <b><a name='subtract'></a>subtract</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> a,
        <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> b
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - a is a sparse vector or dlib::matrix
            - b is a sparse vector or dlib::matrix
        ensures
            - returns a vector or matrix which represents a-b.  If the inputs are
              sparse vectors then the result is a sparse vector.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>long</u></font> <b><a name='max_index_plus_one'></a>max_index_plus_one</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> samples
    <font face='Lucida Console'>)</font>; 
    <font color='#009900'>/*!
        requires
            - samples == a single vector (either sparse or dense), or a container
              of vectors which is either a dlib::matrix of vectors or something 
              convertible to a dlib::matrix via mat() (e.g. a std::vector)
              Valid types of samples include (but are not limited to):
                - dlib::matrix&lt;double,0,1&gt;                      // A single dense vector 
                - std::map&lt;unsigned int, double&gt;                // A single sparse vector
                - std::vector&lt;dlib::matrix&lt;double,0,1&gt; &gt;        // An array of dense vectors
                - std::vector&lt;std::map&lt;unsigned int, double&gt; &gt;  // An array of sparse vectors
        ensures
            - This function tells you the dimensionality of a set of vectors.  The vectors
              can be either sparse or dense.  
            - if (samples.size() == 0) then
                - returns 0
            - else if (samples contains dense vectors or is a dense vector) then
                - returns the number of elements in the first sample vector.  This means
                  we implicitly assume all dense vectors have the same length)
            - else
                - In this case samples contains sparse vectors or is a sparse vector.  
                - returns the largest element index in any sample + 1.  Note that the element index values
                  are the values stored in std::pair::first.  So this number tells you the dimensionality
                  of a set of sparse vectors.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'><u>long</u></font> NR, <font color='#0000FF'><u>long</u></font> NC, <font color='#0000FF'>typename</font> MM, <font color='#0000FF'>typename</font> L, <font color='#0000FF'>typename</font> SRC, <font color='#0000FF'>typename</font> U<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>inline</font> <font color='#0000FF'><u>void</u></font> <b><a name='add_to'></a>add_to</b> <font face='Lucida Console'>(</font>
        matrix<font color='#5555FF'>&lt;</font>T,NR,NC,MM,L<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> dest,
        <font color='#0000FF'>const</font> SRC<font color='#5555FF'>&amp;</font> src,
        <font color='#0000FF'>const</font> U<font color='#5555FF'>&amp;</font> C <font color='#5555FF'>=</font> <font color='#979000'>1</font>
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - SRC == a matrix expression or an unsorted sparse vector
            - is_vector(dest) == true
            - Let MAX denote the largest element index in src.
              Then we require that:
                - MAX &lt; dest.size()
                - (i.e. dest needs to be big enough to contain all the elements of src)
        ensures
            - #dest == dest + C*src
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'><u>long</u></font> NR, <font color='#0000FF'><u>long</u></font> NC, <font color='#0000FF'>typename</font> MM, <font color='#0000FF'>typename</font> L, <font color='#0000FF'>typename</font> SRC, <font color='#0000FF'>typename</font> U<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>inline</font> <font color='#0000FF'><u>void</u></font> <b><a name='subtract_from'></a>subtract_from</b> <font face='Lucida Console'>(</font>
        matrix<font color='#5555FF'>&lt;</font>T,NR,NC,MM,L<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> dest,
        <font color='#0000FF'>const</font> SRC<font color='#5555FF'>&amp;</font> src,
        <font color='#0000FF'>const</font> U<font color='#5555FF'>&amp;</font> C <font color='#5555FF'>=</font> <font color='#979000'>1</font>
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - SRC == a matrix expression or an unsorted sparse vector
            - is_vector(dest) == true
            - Let MAX denote the largest element index in src.
              Then we require that:
                - MAX &lt; dest.size()
                - (i.e. dest needs to be big enough to contain all the elements of src)
        ensures
            - #dest == dest - C*src
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>typename</font> T::value_type::second_type <b><a name='min'></a>min</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> vect
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - T == an unsorted sparse vector
        ensures
            - returns the minimum value in the sparse vector vect.  Note that
              this value is always &lt;= 0 since a sparse vector has an unlimited number
              of 0 elements.
    !*/</font>

<font color='#009900'>// ------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>typename</font> T::value_type::second_type <b><a name='max'></a>max</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> vect
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - T == an unsorted sparse vector
        ensures
            - returns the maximum value in the sparse vector vect.  Note that
              this value is always &gt;= 0 since a sparse vector has an unlimited number
              of 0 elements.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> sample_type
        <font color='#5555FF'>&gt;</font>
    matrix<font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> sample_type::value_type::second_type,<font color='#979000'>0</font>,<font color='#979000'>1</font><font color='#5555FF'>&gt;</font> <b><a name='sparse_to_dense'></a>sparse_to_dense</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> sample_type<font color='#5555FF'>&amp;</font> vect
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - vect must be a sparse vector or a dense column vector.
        ensures
            - converts the single sparse or dense vector vect to a dense (column matrix form)
              representation.  That is, this function returns a vector V such that:
                - V.size() == max_index_plus_one(vect)
                - for all valid j:
                    - V(j) == The value of the j'th dimension of the vector vect.  Note 
                      that V(j) is zero if it is a sparse vector that doesn't contain an 
                      entry for the j'th dimension.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> sample_type
        <font color='#5555FF'>&gt;</font>
    matrix<font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> sample_type::value_type::second_type,<font color='#979000'>0</font>,<font color='#979000'>1</font><font color='#5555FF'>&gt;</font> <b><a name='sparse_to_dense'></a>sparse_to_dense</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> sample_type<font color='#5555FF'>&amp;</font> vect,
        <font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>long</u></font> num_dimensions 
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - vect must be a sparse vector or a dense column vector.
        ensures
            - converts the single sparse or dense vector vect to a dense (column matrix form)
              representation.  That is, this function returns a vector V such that:
                - V.size() == num_dimensions 
                - for all valid j:
                    - V(j) == The value of the j'th dimension of the vector vect.  Note 
                      that V(j) is zero if it is a sparse vector that doesn't contain an 
                      entry for the j'th dimension.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> sample_type, 
        <font color='#0000FF'>typename</font> alloc
        <font color='#5555FF'>&gt;</font>
    std::vector<font color='#5555FF'>&lt;</font>matrix<font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> sample_type::value_type::second_type,<font color='#979000'>0</font>,<font color='#979000'>1</font><font color='#5555FF'>&gt;</font> <font color='#5555FF'>&gt;</font> <b><a name='sparse_to_dense'></a>sparse_to_dense</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> std::vector<font color='#5555FF'>&lt;</font>sample_type, alloc<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> samples
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - all elements of samples must be sparse vectors or dense column vectors.
        ensures
            - converts from sparse sample vectors to dense (column matrix form)
            - That is, this function returns a std::vector R such that:
                - R contains column matrices    
                - R.size() == samples.size()
                - for all valid i: 
                    - R[i] == sparse_to_dense(samples[i], max_index_plus_one(samples))
                      (i.e. the dense (i.e. dlib::matrix) version of the sparse sample
                      given by samples[i].)
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> sample_type, 
        <font color='#0000FF'>typename</font> alloc
        <font color='#5555FF'>&gt;</font>
    std::vector<font color='#5555FF'>&lt;</font>matrix<font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> sample_type::value_type::second_type,<font color='#979000'>0</font>,<font color='#979000'>1</font><font color='#5555FF'>&gt;</font> <font color='#5555FF'>&gt;</font> <b><a name='sparse_to_dense'></a>sparse_to_dense</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> std::vector<font color='#5555FF'>&lt;</font>sample_type, alloc<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> samples,
        <font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>long</u></font> num_dimensions 
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - all elements of samples must be sparse vectors or dense column vectors.
        ensures
            - converts from sparse sample vectors to dense (column matrix form)
            - That is, this function returns a std::vector R such that:
                - R contains column matrices    
                - R.size() == samples.size()
                - for all valid i: 
                    - R[i] == sparse_to_dense(samples[i], num_dimensions)
                      (i.e. the dense (i.e. dlib::matrix) version of the sparse sample
                      given by samples[i].)
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> T
        <font color='#5555FF'>&gt;</font>
    T <b><a name='make_sparse_vector'></a>make_sparse_vector</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> v
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - v is an unsorted sparse vector
        ensures
            - returns a copy of v which is a sparse vector. 
              (i.e. it will be properly sorted and not have any duplicate key values but
              will still logically represent the same vector).
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> T
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'><u>void</u></font> <b><a name='make_sparse_vector_inplace'></a>make_sparse_vector_inplace</b><font face='Lucida Console'>(</font>
        T<font color='#5555FF'>&amp;</font> vect
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - v is an unsorted sparse vector
        ensures
            - vect == make_sparse_vector(vect)
            - This function is just an optimized version of make_sparse_vector(), in
              particular, when T is a std::vector&lt;std::pair&lt;&gt;&gt; type it is much more
              efficient.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> EXP, 
        <font color='#0000FF'>typename</font> T, 
        <font color='#0000FF'><u>long</u></font> NR, 
        <font color='#0000FF'><u>long</u></font> NC, 
        <font color='#0000FF'>typename</font> MM, 
        <font color='#0000FF'>typename</font> L
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'><u>void</u></font> <b><a name='sparse_matrix_vector_multiply'></a>sparse_matrix_vector_multiply</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> std::vector<font color='#5555FF'>&lt;</font>sample_pair<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> edges,
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&lt;</font>EXP<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> v,
        matrix<font color='#5555FF'>&lt;</font>T,NR,NC,MM,L<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> result
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - is_col_vector(v) == true
            - max_index_plus_one(edges) &lt;= v.size()
        ensures
            - Interprets edges as representing a symmetric sparse matrix M.  The elements
              of M are defined such that, for all valid i,j:
                - M(i,j) == sum of edges[k].distance() for all k where edges[k]==sample_pair(i,j) 
                - This means that any element of M that doesn't have any edges associated
                  with it will have a value of 0.
            - #result == M*v
              (i.e. this function multiplies the vector v with the sparse matrix
              represented by edges and stores the output into result)
            - get_rect(#result) == get_rect(v)
              (i.e. result will have the same dimensions as v)
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> EXP, 
        <font color='#0000FF'>typename</font> T, 
        <font color='#0000FF'><u>long</u></font> NR, 
        <font color='#0000FF'><u>long</u></font> NC, 
        <font color='#0000FF'>typename</font> MM, 
        <font color='#0000FF'>typename</font> L
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'><u>void</u></font> <b><a name='sparse_matrix_vector_multiply'></a>sparse_matrix_vector_multiply</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> std::vector<font color='#5555FF'>&lt;</font>ordered_sample_pair<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> edges,
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&lt;</font>EXP<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> v,
        matrix<font color='#5555FF'>&lt;</font>T,NR,NC,MM,L<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> result
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - is_col_vector(v) == true
            - max_index_plus_one(edges) &lt;= v.size()
        ensures
            - Interprets edges as representing a square sparse matrix M.  The elements of M
              are defined such that, for all valid i,j:
                - M(i,j) == sum of edges[k].distance() for all k where edges[k]==ordered_sample_pair(i,j) 
                - This means that any element of M that doesn't have any edges associated
                  with it will have a value of 0.
            - #result == M*v
              (i.e. this function multiplies the vector v with the sparse matrix
              represented by edges and stores the output into result)
            - get_rect(#result) == get_rect(v)
              (i.e. result will have the same dimensions as v)
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> EXP
        <font color='#5555FF'>&gt;</font>
    matrix<font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> EXP::type,<font color='#979000'>0</font>,<font color='#979000'>1</font><font color='#5555FF'>&gt;</font> <b><a name='sparse_matrix_vector_multiply'></a>sparse_matrix_vector_multiply</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> std::vector<font color='#5555FF'>&lt;</font>sample_pair<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> edges,
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&lt;</font>EXP<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> v
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - is_col_vector(v) == true
            - max_index_plus_one(edges) &lt;= v.size()
        ensures
            - This is just a convenience routine for invoking the above
              sparse_matrix_vector_multiply() routine.  In particular, it just calls
              sparse_matrix_vector_multiply() with a temporary result matrix and then
              returns the result.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> EXP
        <font color='#5555FF'>&gt;</font>
    matrix<font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> EXP::type,<font color='#979000'>0</font>,<font color='#979000'>1</font><font color='#5555FF'>&gt;</font> <b><a name='sparse_matrix_vector_multiply'></a>sparse_matrix_vector_multiply</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> std::vector<font color='#5555FF'>&lt;</font>ordered_sample_pair<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> edges,
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&lt;</font>EXP<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> v
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - is_col_vector(v) == true
            - max_index_plus_one(edges) &lt;= v.size()
        ensures
            - This is just a convenience routine for invoking the above
              sparse_matrix_vector_multiply() routine.  In particular, it just calls
              sparse_matrix_vector_multiply() with a temporary result matrix and then
              returns the result.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> EXP, 
        <font color='#0000FF'>typename</font> sparse_vector_type,
        <font color='#0000FF'>typename</font> T,
        <font color='#0000FF'><u>long</u></font> NR,
        <font color='#0000FF'><u>long</u></font> NC,
        <font color='#0000FF'>typename</font> MM,
        <font color='#0000FF'>typename</font> L
        <font color='#5555FF'>&gt;</font>
    <font color='#0000FF'><u>void</u></font> <b><a name='sparse_matrix_vector_multiply'></a>sparse_matrix_vector_multiply</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&lt;</font>EXP<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> m,
        <font color='#0000FF'>const</font> sparse_vector_type<font color='#5555FF'>&amp;</font> v,
        matrix<font color='#5555FF'>&lt;</font>T,NR,NC,MM,L<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> result
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - max_index_plus_one(v) &lt;= m.nc()
            - v == an unsorted sparse vector
        ensures
            - #result == m*v
              (i.e. multiply m by the vector v and store the output in result)
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font>
        <font color='#0000FF'>typename</font> EXP, 
        <font color='#0000FF'>typename</font> sparse_vector_type
        <font color='#5555FF'>&gt;</font>
    matrix<font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> EXP::type,<font color='#979000'>0</font>,<font color='#979000'>1</font><font color='#5555FF'>&gt;</font> <b><a name='sparse_matrix_vector_multiply'></a>sparse_matrix_vector_multiply</b> <font face='Lucida Console'>(</font>
        <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&lt;</font>EXP<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> m,
        <font color='#0000FF'>const</font> sparse_vector_type<font color='#5555FF'>&amp;</font> v
    <font face='Lucida Console'>)</font>;
    <font color='#009900'>/*!
        requires
            - max_index_plus_one(v) &lt;= m.nc()
            - v == an unsorted sparse vector
        ensures
            - returns m*v
              (i.e. multiply m by the vector v and return the resulting vector)
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
<b>}</b>

<font color='#0000FF'>#endif</font> <font color='#009900'>// DLIB_SVm_SPARSE_VECTOR_ABSTRACT_
</font>



</pre></body></html>