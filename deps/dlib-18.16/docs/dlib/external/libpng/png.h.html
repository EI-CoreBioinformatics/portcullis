<html><!-- Created using the cpp_pretty_printer from the dlib C++ library.  See http://dlib.net for updates. --><head><title>dlib C++ Library - png.h</title></head><body bgcolor='white'><pre>

<font color='#009900'>/* png.h - header file for PNG reference library
 *
 * libpng version 1.6.7 - November 14, 2013
 * Copyright (c) 1998-2013 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license (See LICENSE, below)
 *
 * Authors and maintainers:
 *   libpng versions 0.71, May 1995, through 0.88, January 1996: Guy Schalnat
 *   libpng versions 0.89c, June 1996, through 0.96, May 1997: Andreas Dilger
 *   libpng versions 0.97, January 1998, through 1.6.7 - November 14, 2013: Glenn
 *   See also "Contributing Authors", below.
 *
 * Note about libpng version numbers:
 *
 *   Due to various miscommunications, unforeseen code incompatibilities
 *   and occasional factors outside the authors' control, version numbering
 *   on the library has not always been consistent and straightforward.
 *   The following table summarizes matters since version 0.89c, which was
 *   the first widely used release:
 *
 *    source                 png.h  png.h  shared-lib
 *    version                string   int  version
 *    -------                ------ -----  ----------
 *    0.89c "1.0 beta 3"     0.89      89  1.0.89
 *    0.90  "1.0 beta 4"     0.90      90  0.90  [should have been 2.0.90]
 *    0.95  "1.0 beta 5"     0.95      95  0.95  [should have been 2.0.95]
 *    0.96  "1.0 beta 6"     0.96      96  0.96  [should have been 2.0.96]
 *    0.97b "1.00.97 beta 7" 1.00.97   97  1.0.1 [should have been 2.0.97]
 *    0.97c                  0.97      97  2.0.97
 *    0.98                   0.98      98  2.0.98
 *    0.99                   0.99      98  2.0.99
 *    0.99a-m                0.99      99  2.0.99
 *    1.00                   1.00     100  2.1.0 [100 should be 10000]
 *    1.0.0      (from here on, the   100  2.1.0 [100 should be 10000]
 *    1.0.1       png.h string is   10001  2.1.0
 *    1.0.1a-e    identical to the  10002  from here on, the shared library
 *    1.0.2       source version)   10002  is 2.V where V is the source code
 *    1.0.2a-b                      10003  version, except as noted.
 *    1.0.3                         10003
 *    1.0.3a-d                      10004
 *    1.0.4                         10004
 *    1.0.4a-f                      10005
 *    1.0.5 (+ 2 patches)           10005
 *    1.0.5a-d                      10006
 *    1.0.5e-r                      10100 (not source compatible)
 *    1.0.5s-v                      10006 (not binary compatible)
 *    1.0.6 (+ 3 patches)           10006 (still binary incompatible)
 *    1.0.6d-f                      10007 (still binary incompatible)
 *    1.0.6g                        10007
 *    1.0.6h                        10007  10.6h (testing xy.z so-numbering)
 *    1.0.6i                        10007  10.6i
 *    1.0.6j                        10007  2.1.0.6j (incompatible with 1.0.0)
 *    1.0.7beta11-14        DLLNUM  10007  2.1.0.7beta11-14 (binary compatible)
 *    1.0.7beta15-18           1    10007  2.1.0.7beta15-18 (binary compatible)
 *    1.0.7rc1-2               1    10007  2.1.0.7rc1-2 (binary compatible)
 *    1.0.7                    1    10007  (still compatible)
 *    1.0.8beta1-4             1    10008  2.1.0.8beta1-4
 *    1.0.8rc1                 1    10008  2.1.0.8rc1
 *    1.0.8                    1    10008  2.1.0.8
 *    1.0.9beta1-6             1    10009  2.1.0.9beta1-6
 *    1.0.9rc1                 1    10009  2.1.0.9rc1
 *    1.0.9beta7-10            1    10009  2.1.0.9beta7-10
 *    1.0.9rc2                 1    10009  2.1.0.9rc2
 *    1.0.9                    1    10009  2.1.0.9
 *    1.0.10beta1              1    10010  2.1.0.10beta1
 *    1.0.10rc1                1    10010  2.1.0.10rc1
 *    1.0.10                   1    10010  2.1.0.10
 *    1.0.11beta1-3            1    10011  2.1.0.11beta1-3
 *    1.0.11rc1                1    10011  2.1.0.11rc1
 *    1.0.11                   1    10011  2.1.0.11
 *    1.0.12beta1-2            2    10012  2.1.0.12beta1-2
 *    1.0.12rc1                2    10012  2.1.0.12rc1
 *    1.0.12                   2    10012  2.1.0.12
 *    1.1.0a-f                 -    10100  2.1.1.0a-f (branch abandoned)
 *    1.2.0beta1-2             2    10200  2.1.2.0beta1-2
 *    1.2.0beta3-5             3    10200  3.1.2.0beta3-5
 *    1.2.0rc1                 3    10200  3.1.2.0rc1
 *    1.2.0                    3    10200  3.1.2.0
 *    1.2.1beta1-4             3    10201  3.1.2.1beta1-4
 *    1.2.1rc1-2               3    10201  3.1.2.1rc1-2
 *    1.2.1                    3    10201  3.1.2.1
 *    1.2.2beta1-6            12    10202  12.so.0.1.2.2beta1-6
 *    1.0.13beta1             10    10013  10.so.0.1.0.13beta1
 *    1.0.13rc1               10    10013  10.so.0.1.0.13rc1
 *    1.2.2rc1                12    10202  12.so.0.1.2.2rc1
 *    1.0.13                  10    10013  10.so.0.1.0.13
 *    1.2.2                   12    10202  12.so.0.1.2.2
 *    1.2.3rc1-6              12    10203  12.so.0.1.2.3rc1-6
 *    1.2.3                   12    10203  12.so.0.1.2.3
 *    1.2.4beta1-3            13    10204  12.so.0.1.2.4beta1-3
 *    1.0.14rc1               13    10014  10.so.0.1.0.14rc1
 *    1.2.4rc1                13    10204  12.so.0.1.2.4rc1
 *    1.0.14                  10    10014  10.so.0.1.0.14
 *    1.2.4                   13    10204  12.so.0.1.2.4
 *    1.2.5beta1-2            13    10205  12.so.0.1.2.5beta1-2
 *    1.0.15rc1-3             10    10015  10.so.0.1.0.15rc1-3
 *    1.2.5rc1-3              13    10205  12.so.0.1.2.5rc1-3
 *    1.0.15                  10    10015  10.so.0.1.0.15
 *    1.2.5                   13    10205  12.so.0.1.2.5
 *    1.2.6beta1-4            13    10206  12.so.0.1.2.6beta1-4
 *    1.0.16                  10    10016  10.so.0.1.0.16
 *    1.2.6                   13    10206  12.so.0.1.2.6
 *    1.2.7beta1-2            13    10207  12.so.0.1.2.7beta1-2
 *    1.0.17rc1               10    10017  12.so.0.1.0.17rc1
 *    1.2.7rc1                13    10207  12.so.0.1.2.7rc1
 *    1.0.17                  10    10017  12.so.0.1.0.17
 *    1.2.7                   13    10207  12.so.0.1.2.7
 *    1.2.8beta1-5            13    10208  12.so.0.1.2.8beta1-5
 *    1.0.18rc1-5             10    10018  12.so.0.1.0.18rc1-5
 *    1.2.8rc1-5              13    10208  12.so.0.1.2.8rc1-5
 *    1.0.18                  10    10018  12.so.0.1.0.18
 *    1.2.8                   13    10208  12.so.0.1.2.8
 *    1.2.9beta1-3            13    10209  12.so.0.1.2.9beta1-3
 *    1.2.9beta4-11           13    10209  12.so.0.9[.0]
 *    1.2.9rc1                13    10209  12.so.0.9[.0]
 *    1.2.9                   13    10209  12.so.0.9[.0]
 *    1.2.10beta1-7           13    10210  12.so.0.10[.0]
 *    1.2.10rc1-2             13    10210  12.so.0.10[.0]
 *    1.2.10                  13    10210  12.so.0.10[.0]
 *    1.4.0beta1-5            14    10400  14.so.0.0[.0]
 *    1.2.11beta1-4           13    10211  12.so.0.11[.0]
 *    1.4.0beta7-8            14    10400  14.so.0.0[.0]
 *    1.2.11                  13    10211  12.so.0.11[.0]
 *    1.2.12                  13    10212  12.so.0.12[.0]
 *    1.4.0beta9-14           14    10400  14.so.0.0[.0]
 *    1.2.13                  13    10213  12.so.0.13[.0]
 *    1.4.0beta15-36          14    10400  14.so.0.0[.0]
 *    1.4.0beta37-87          14    10400  14.so.14.0[.0]
 *    1.4.0rc01               14    10400  14.so.14.0[.0]
 *    1.4.0beta88-109         14    10400  14.so.14.0[.0]
 *    1.4.0rc02-08            14    10400  14.so.14.0[.0]
 *    1.4.0                   14    10400  14.so.14.0[.0]
 *    1.4.1beta01-03          14    10401  14.so.14.1[.0]
 *    1.4.1rc01               14    10401  14.so.14.1[.0]
 *    1.4.1beta04-12          14    10401  14.so.14.1[.0]
 *    1.4.1                   14    10401  14.so.14.1[.0]
 *    1.4.2                   14    10402  14.so.14.2[.0]
 *    1.4.3                   14    10403  14.so.14.3[.0]
 *    1.4.4                   14    10404  14.so.14.4[.0]
 *    1.5.0beta01-58          15    10500  15.so.15.0[.0]
 *    1.5.0rc01-07            15    10500  15.so.15.0[.0]
 *    1.5.0                   15    10500  15.so.15.0[.0]
 *    1.5.1beta01-11          15    10501  15.so.15.1[.0]
 *    1.5.1rc01-02            15    10501  15.so.15.1[.0]
 *    1.5.1                   15    10501  15.so.15.1[.0]
 *    1.5.2beta01-03          15    10502  15.so.15.2[.0]
 *    1.5.2rc01-03            15    10502  15.so.15.2[.0]
 *    1.5.2                   15    10502  15.so.15.2[.0]
 *    1.5.3beta01-10          15    10503  15.so.15.3[.0]
 *    1.5.3rc01-02            15    10503  15.so.15.3[.0]
 *    1.5.3beta11             15    10503  15.so.15.3[.0]
 *    1.5.3 [omitted]
 *    1.5.4beta01-08          15    10504  15.so.15.4[.0]
 *    1.5.4rc01               15    10504  15.so.15.4[.0]
 *    1.5.4                   15    10504  15.so.15.4[.0]
 *    1.5.5beta01-08          15    10505  15.so.15.5[.0]
 *    1.5.5rc01               15    10505  15.so.15.5[.0]
 *    1.5.5                   15    10505  15.so.15.5[.0]
 *    1.5.6beta01-07          15    10506  15.so.15.6[.0]
 *    1.5.6rc01-03            15    10506  15.so.15.6[.0]
 *    1.5.6                   15    10506  15.so.15.6[.0]
 *    1.5.7beta01-05          15    10507  15.so.15.7[.0]
 *    1.5.7rc01-03            15    10507  15.so.15.7[.0]
 *    1.5.7                   15    10507  15.so.15.7[.0]
 *    1.6.0beta01-40          16    10600  16.so.16.0[.0]
 *    1.6.0rc01-08            16    10600  16.so.16.0[.0]
 *    1.6.0                   16    10600  16.so.16.0[.0]
 *    1.6.1beta01-09          16    10601  16.so.16.1[.0]
 *    1.6.1rc01               16    10601  16.so.16.1[.0]
 *    1.6.1                   16    10601  16.so.16.1[.0]
 *    1.6.2beta01             16    10602  16.so.16.2[.0]
 *    1.6.2rc01-06            16    10602  16.so.16.2[.0]
 *    1.6.2                   16    10602  16.so.16.2[.0]
 *    1.6.3beta01-11          16    10603  16.so.16.3[.0]
 *    1.6.3rc01               16    10603  16.so.16.3[.0]
 *    1.6.3                   16    10603  16.so.16.3[.0]
 *    1.6.4beta01-02          16    10604  16.so.16.4[.0]
 *    1.6.4rc01               16    10604  16.so.16.4[.0]
 *    1.6.4                   16    10604  16.so.16.4[.0]
 *    1.6.5                   16    10605  16.so.16.5[.0]
 *    1.6.6                   16    10606  16.so.16.6[.0]
 *    1.6.7beta01-04          16    10607  16.so.16.7[.0]
 *    1.6.7rc01-02            16    10607  16.so.16.7[.0]
 *    1.6.7                   16    10607  16.so.16.7[.0]
 *
 *   Henceforth the source version will match the shared-library major
 *   and minor numbers; the shared-library major version number will be
 *   used for changes in backward compatibility, as it is intended.  The
 *   PNG_LIBPNG_VER macro, which is not used within libpng but is available
 *   for applications, is an unsigned integer of the form xyyzz corresponding
 *   to the source version x.y.z (leading zeros in y and z).  Beta versions
 *   were given the previous public release number plus a letter, until
 *   version 1.0.6j; from then on they were given the upcoming public
 *   release number plus "betaNN" or "rcNN".
 *
 *   Binary incompatibility exists only when applications make direct access
 *   to the info_ptr or png_ptr members through png.h, and the compiled
 *   application is loaded with a different version of the library.
 *
 *   DLLNUM will change each time there are forward or backward changes
 *   in binary compatibility (e.g., when a new feature is added).
 *
 * See libpng-manual.txt or libpng.3 for more information.  The PNG
 * specification is available as a W3C Recommendation and as an ISO
 * Specification, &lt;http://www.w3.org/TR/2003/REC-PNG-20031110/
 */</font>

<font color='#009900'>/*
 * COPYRIGHT NOTICE, DISCLAIMER, and LICENSE:
 *
 * If you modify libpng you may insert additional notices immediately following
 * this sentence.
 *
 * This code is released under the libpng license.
 *
 * libpng versions 1.2.6, August 15, 2004, through 1.6.7, November 14, 2013, are
 * Copyright (c) 2004, 2006-2013 Glenn Randers-Pehrson, and are
 * distributed according to the same disclaimer and license as libpng-1.2.5
 * with the following individual added to the list of Contributing Authors:
 *
 *    Cosmin Truta
 *
 * libpng versions 1.0.7, July 1, 2000, through 1.2.5, October 3, 2002, are
 * Copyright (c) 2000-2002 Glenn Randers-Pehrson, and are
 * distributed according to the same disclaimer and license as libpng-1.0.6
 * with the following individuals added to the list of Contributing Authors:
 *
 *    Simon-Pierre Cadieux
 *    Eric S. Raymond
 *    Gilles Vollant
 *
 * and with the following additions to the disclaimer:
 *
 *    There is no warranty against interference with your enjoyment of the
 *    library or against infringement.  There is no warranty that our
 *    efforts or the library will fulfill any of your particular purposes
 *    or needs.  This library is provided with all faults, and the entire
 *    risk of satisfactory quality, performance, accuracy, and effort is with
 *    the user.
 *
 * libpng versions 0.97, January 1998, through 1.0.6, March 20, 2000, are
 * Copyright (c) 1998, 1999, 2000 Glenn Randers-Pehrson, and are
 * distributed according to the same disclaimer and license as libpng-0.96,
 * with the following individuals added to the list of Contributing Authors:
 *
 *    Tom Lane
 *    Glenn Randers-Pehrson
 *    Willem van Schaik
 *
 * libpng versions 0.89, June 1996, through 0.96, May 1997, are
 * Copyright (c) 1996, 1997 Andreas Dilger
 * Distributed according to the same disclaimer and license as libpng-0.88,
 * with the following individuals added to the list of Contributing Authors:
 *
 *    John Bowler
 *    Kevin Bracey
 *    Sam Bushell
 *    Magnus Holmgren
 *    Greg Roelofs
 *    Tom Tanner
 *
 * libpng versions 0.5, May 1995, through 0.88, January 1996, are
 * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
 *
 * For the purposes of this copyright and license, "Contributing Authors"
 * is defined as the following set of individuals:
 *
 *    Andreas Dilger
 *    Dave Martindale
 *    Guy Eric Schalnat
 *    Paul Schmidt
 *    Tim Wegner
 *
 * The PNG Reference Library is supplied "AS IS".  The Contributing Authors
 * and Group 42, Inc. disclaim all warranties, expressed or implied,
 * including, without limitation, the warranties of merchantability and of
 * fitness for any purpose.  The Contributing Authors and Group 42, Inc.
 * assume no liability for direct, indirect, incidental, special, exemplary,
 * or consequential damages, which may result from the use of the PNG
 * Reference Library, even if advised of the possibility of such damage.
 *
 * Permission is hereby granted to use, copy, modify, and distribute this
 * source code, or portions hereof, for any purpose, without fee, subject
 * to the following restrictions:
 *
 *   1. The origin of this source code must not be misrepresented.
 *
 *   2. Altered versions must be plainly marked as such and must not
 *      be misrepresented as being the original source.
 *
 *   3. This Copyright notice may not be removed or altered from
 *      any source or altered source distribution.
 *
 * The Contributing Authors and Group 42, Inc. specifically permit, without
 * fee, and encourage the use of this source code as a component to
 * supporting the PNG file format in commercial products.  If you use this
 * source code in a product, acknowledgment is not required but would be
 * appreciated.
 */</font>

<font color='#009900'>/*
 * A "png_get_copyright" function is available, for convenient use in "about"
 * boxes and the like:
 *
 *     printf("%s", png_get_copyright(NULL));
 *
 * Also, the PNG logo (in PNG format, of course) is supplied in the
 * files "pngbar.png" and "pngbar.jpg (88x31) and "pngnow.png" (98x31).
 */</font>

<font color='#009900'>/*
 * Libpng is OSI Certified Open Source Software.  OSI Certified is a
 * certification mark of the Open Source Initiative.
 */</font>

<font color='#009900'>/*
 * The contributing authors would like to thank all those who helped
 * with testing, bug fixes, and patience.  This wouldn't have been
 * possible without all of you.
 *
 * Thanks to Frank J. T. Wojcik for helping with the documentation.
 */</font>

<font color='#009900'>/*
 * Y2K compliance in libpng:
 * =========================
 *
 *    November 14, 2013
 *
 *    Since the PNG Development group is an ad-hoc body, we can't make
 *    an official declaration.
 *
 *    This is your unofficial assurance that libpng from version 0.71 and
 *    upward through 1.6.7 are Y2K compliant.  It is my belief that
 *    earlier versions were also Y2K compliant.
 *
 *    Libpng only has two year fields.  One is a 2-byte unsigned integer
 *    that will hold years up to 65535.  The other, which is deprecated,
 *    holds the date in text format, and will hold years up to 9999.
 *
 *    The integer is
 *        "png_uint_16 year" in png_time_struct.
 *
 *    The string is
 *        "char time_buffer[29]" in png_struct.  This is no longer used
 *    in libpng-1.6.x and will be removed from libpng-1.7.0.
 *
 *    There are seven time-related functions:
 *        png.c: png_convert_to_rfc_1123_buffer() in png.c
 *          (formerly png_convert_to_rfc_1123() prior to libpng-1.5.x and
 *          png_convert_to_rfc_1152() in error prior to libpng-0.98)
 *        png_convert_from_struct_tm() in pngwrite.c, called in pngwrite.c
 *        png_convert_from_time_t() in pngwrite.c
 *        png_get_tIME() in pngget.c
 *        png_handle_tIME() in pngrutil.c, called in pngread.c
 *        png_set_tIME() in pngset.c
 *        png_write_tIME() in pngwutil.c, called in pngwrite.c
 *
 *    All handle dates properly in a Y2K environment.  The
 *    png_convert_from_time_t() function calls gmtime() to convert from system
 *    clock time, which returns (year - 1900), which we properly convert to
 *    the full 4-digit year.  There is a possibility that libpng applications
 *    are not passing 4-digit years into the png_convert_to_rfc_1123_buffer()
 *    function, or that they are incorrectly passing only a 2-digit year
 *    instead of "year - 1900" into the png_convert_from_struct_tm() function,
 *    but this is not under our control.  The libpng documentation has always
 *    stated that it works with 4-digit years, and the APIs have been
 *    documented as such.
 *
 *    The tIME chunk itself is also Y2K compliant.  It uses a 2-byte unsigned
 *    integer to hold the year, and can hold years as large as 65535.
 *
 *    zlib, upon which libpng depends, is also Y2K compliant.  It contains
 *    no date-related code.
 *
 *       Glenn Randers-Pehrson
 *       libpng maintainer
 *       PNG Development Group
 */</font>

<font color='#0000FF'>#ifndef</font> PNG_H
<font color='#0000FF'>#define</font> PNG_H

<font color='#009900'>/* This is not the place to learn how to use libpng. The file libpng-manual.txt
 * describes how to use libpng, and the file example.c summarizes it
 * with some code on which to build.  This file is useful for looking
 * at the actual function definitions and structure components.
 *
 * If you just need to read a PNG file and don't want to read the documentation
 * skip to the end of this file and read the section entitled 'simplified API'.
 */</font>

<font color='#009900'>/* Version information for png.h - this should match the version in png.c */</font>
<font color='#0000FF'>#define</font> PNG_LIBPNG_VER_STRING "<font color='#CC0000'>1.6.7</font>"
<font color='#0000FF'>#define</font> PNG_HEADER_VERSION_STRING \
     "<font color='#CC0000'> libpng version 1.6.7 - November 14, 2013\n</font>"

<font color='#0000FF'>#define</font> PNG_LIBPNG_VER_SONUM   <font color='#979000'>16</font>
<font color='#0000FF'>#define</font> PNG_LIBPNG_VER_DLLNUM  <font color='#979000'>16</font>

<font color='#009900'>/* These should match the first 3 components of PNG_LIBPNG_VER_STRING: */</font>
<font color='#0000FF'>#define</font> PNG_LIBPNG_VER_MAJOR   <font color='#979000'>1</font>
<font color='#0000FF'>#define</font> PNG_LIBPNG_VER_MINOR   <font color='#979000'>6</font>
<font color='#0000FF'>#define</font> PNG_LIBPNG_VER_RELEASE <font color='#979000'>7</font>

<font color='#009900'>/* This should match the numeric part of the final component of
 * PNG_LIBPNG_VER_STRING, omitting any leading zero:
 */</font>

<font color='#0000FF'>#define</font> PNG_LIBPNG_VER_BUILD  <font color='#979000'>0</font>

<font color='#009900'>/* Release Status */</font>
<font color='#0000FF'>#define</font> PNG_LIBPNG_BUILD_ALPHA    <font color='#979000'>1</font>
<font color='#0000FF'>#define</font> PNG_LIBPNG_BUILD_BETA     <font color='#979000'>2</font>
<font color='#0000FF'>#define</font> PNG_LIBPNG_BUILD_RC       <font color='#979000'>3</font>
<font color='#0000FF'>#define</font> PNG_LIBPNG_BUILD_STABLE   <font color='#979000'>4</font>
<font color='#0000FF'>#define</font> PNG_LIBPNG_BUILD_RELEASE_STATUS_MASK <font color='#979000'>7</font>

<font color='#009900'>/* Release-Specific Flags */</font>
<font color='#0000FF'>#define</font> PNG_LIBPNG_BUILD_PATCH    <font color='#979000'>8</font> <font color='#009900'>/* Can be OR'ed with
                                       PNG_LIBPNG_BUILD_STABLE only */</font>
<font color='#0000FF'>#define</font> PNG_LIBPNG_BUILD_PRIVATE <font color='#979000'>16</font> <font color='#009900'>/* Cannot be OR'ed with
                                       PNG_LIBPNG_BUILD_SPECIAL */</font>
<font color='#0000FF'>#define</font> PNG_LIBPNG_BUILD_SPECIAL <font color='#979000'>32</font> <font color='#009900'>/* Cannot be OR'ed with
                                       PNG_LIBPNG_BUILD_PRIVATE */</font>

<font color='#0000FF'>#define</font> PNG_LIBPNG_BUILD_BASE_TYPE PNG_LIBPNG_BUILD_STABLE

<font color='#009900'>/* Careful here.  At one time, Guy wanted to use 082, but that would be octal.
 * We must not include leading zeros.
 * Versions 0.7 through 1.0.0 were in the range 0 to 100 here (only
 * version 1.0.0 was mis-numbered 100 instead of 10000).  From
 * version 1.0.1 it's    xxyyzz, where x=major, y=minor, z=release
 */</font>
<font color='#0000FF'>#define</font> PNG_LIBPNG_VER <font color='#979000'>10607</font> <font color='#009900'>/* 1.6.7 */</font>

<font color='#009900'>/* Library configuration: these options cannot be changed after
 * the library has been built.
 */</font>
<font color='#0000FF'>#ifndef</font> PNGLCONF_H
    <font color='#009900'>/* If pnglibconf.h is missing, you can
     * copy scripts/pnglibconf.h.prebuilt to pnglibconf.h
     */</font>
#   include "<font color='#CC0000'>pnglibconf.h</font>"
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifndef</font> PNG_VERSION_INFO_ONLY
   <font color='#009900'>/* Machine specific configuration. */</font>
#  include "<font color='#CC0000'>pngconf.h</font>"
<font color='#0000FF'>#endif</font>

<font color='#009900'>/*
 * Added at libpng-1.2.8
 *
 * Ref MSDN: Private as priority over Special
 * VS_FF_PRIVATEBUILD File *was not* built using standard release
 * procedures. If this value is given, the StringFileInfo block must
 * contain a PrivateBuild string.
 *
 * VS_FF_SPECIALBUILD File *was* built by the original company using
 * standard release procedures but is a variation of the standard
 * file of the same version number. If this value is given, the
 * StringFileInfo block must contain a SpecialBuild string.
 */</font>

<font color='#0000FF'>#ifdef</font> PNG_USER_PRIVATEBUILD <font color='#009900'>/* From pnglibconf.h */</font>
#  define PNG_LIBPNG_BUILD_TYPE \
       <font face='Lucida Console'>(</font>PNG_LIBPNG_BUILD_BASE_TYPE <font color='#5555FF'>|</font> PNG_LIBPNG_BUILD_PRIVATE<font face='Lucida Console'>)</font>
<font color='#0000FF'>#else</font>
#  ifdef PNG_LIBPNG_SPECIALBUILD
#    define PNG_LIBPNG_BUILD_TYPE \
         <font face='Lucida Console'>(</font>PNG_LIBPNG_BUILD_BASE_TYPE <font color='#5555FF'>|</font> PNG_LIBPNG_BUILD_SPECIAL<font face='Lucida Console'>)</font>
#  <font color='#0000FF'>else</font>
#    define <b><a name='PNG_LIBPNG_BUILD_TYPE'></a>PNG_LIBPNG_BUILD_TYPE</b> <font face='Lucida Console'>(</font>PNG_LIBPNG_BUILD_BASE_TYPE<font face='Lucida Console'>)</font>
#  endif
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifndef</font> PNG_VERSION_INFO_ONLY

<font color='#009900'>/* Inhibit C++ name-mangling for libpng functions but not for system calls. */</font>
<font color='#0000FF'>#ifdef</font> __cplusplus
<font color='#0000FF'>extern</font> "<font color='#CC0000'>C</font>" <b>{</b>
<font color='#0000FF'>#endif</font> <font color='#009900'>/* __cplusplus */</font>

<font color='#009900'>/* Version information for C files, stored in png.c.  This had better match
 * the version above.
 */</font>
<font color='#0000FF'>#define</font> png_libpng_ver png_get_header_ver<font face='Lucida Console'>(</font>NULL<font face='Lucida Console'>)</font>

<font color='#009900'>/* This file is arranged in several sections:
 *
 * 1. Any configuration options that can be specified by for the application
 *    code when it is built.  (Build time configuration is in pnglibconf.h)
 * 2. Type definitions (base types are defined in pngconf.h), structure
 *    definitions.
 * 3. Exported library functions.
 * 4. Simplified API.
 *
 * The library source code has additional files (principally pngpriv.h) that
 * allow configuration of the library.
 */</font>
<font color='#009900'>/* Section 1: run time configuration
 * See pnglibconf.h for build time configuration
 *
 * Run time configuration allows the application to choose between
 * implementations of certain arithmetic APIs.  The default is set
 * at build time and recorded in pnglibconf.h, but it is safe to
 * override these (and only these) settings.  Note that this won't
 * change what the library does, only application code, and the
 * settings can (and probably should) be made on a per-file basis
 * by setting the #defines before including png.h
 *
 * Use macros to read integers from PNG data or use the exported
 * functions?
 *   PNG_USE_READ_MACROS: use the macros (see below)  Note that
 *     the macros evaluate their argument multiple times.
 *   PNG_NO_USE_READ_MACROS: call the relevant library function.
 *
 * Use the alternative algorithm for compositing alpha samples that
 * does not use division?
 *   PNG_READ_COMPOSITE_NODIV_SUPPORTED: use the 'no division'
 *      algorithm.
 *   PNG_NO_READ_COMPOSITE_NODIV: use the 'division' algorithm.
 *
 * How to handle benign errors if PNG_ALLOW_BENIGN_ERRORS is
 * false?
 *   PNG_ALLOW_BENIGN_ERRORS: map calls to the benign error
 *      APIs to png_warning.
 * Otherwise the calls are mapped to png_error.
 */</font>

<font color='#009900'>/* Section 2: type definitions, including structures and compile time
 * constants.
 * See pngconf.h for base types that vary by machine/system
 */</font>

<font color='#009900'>/* This triggers a compiler error in png.c, if png.c and png.h
 * do not agree upon the version number.
 */</font>
<font color='#0000FF'>typedef</font> <font color='#0000FF'><u>char</u></font><font color='#5555FF'>*</font> png_libpng_version_1_6_7;

<font color='#009900'>/* Basic control structions.  Read libpng-manual.txt or libpng.3 for more info.
 *
 * png_struct is the cache of information used while reading or writing a single
 * PNG file.  One of these is always required, although the simplified API
 * (below) hides the creation and destruction of it.
 */</font>
<font color='#0000FF'>typedef</font> <font color='#0000FF'>struct</font> png_struct_def png_struct;
<font color='#0000FF'>typedef</font> <font color='#0000FF'>const</font> png_struct <font color='#5555FF'>*</font> png_const_structp;
<font color='#0000FF'>typedef</font> png_struct <font color='#5555FF'>*</font> png_structp;
<font color='#0000FF'>typedef</font> png_struct <font color='#5555FF'>*</font> <font color='#5555FF'>*</font> png_structpp;

<font color='#009900'>/* png_info contains information read from or to be written to a PNG file.  One
 * or more of these must exist while reading or creating a PNG file.  The
 * information is not used by libpng during read but is used to control what
 * gets written when a PNG file is created.  "png_get_" function calls read
 * information during read and "png_set_" functions calls write information
 * when creating a PNG.
 * been moved into a separate header file that is not accessible to
 * applications.  Read libpng-manual.txt or libpng.3 for more info.
 */</font>
<font color='#0000FF'>typedef</font> <font color='#0000FF'>struct</font> png_info_def png_info;
<font color='#0000FF'>typedef</font> png_info <font color='#5555FF'>*</font> png_infop;
<font color='#0000FF'>typedef</font> <font color='#0000FF'>const</font> png_info <font color='#5555FF'>*</font> png_const_infop;
<font color='#0000FF'>typedef</font> png_info <font color='#5555FF'>*</font> <font color='#5555FF'>*</font> png_infopp;

<font color='#009900'>/* Types with names ending 'p' are pointer types.  The corresponding types with
 * names ending 'rp' are identical pointer types except that the pointer is
 * marked 'restrict', which means that it is the only pointer to the object
 * passed to the function.  Applications should not use the 'restrict' types;
 * it is always valid to pass 'p' to a pointer with a function argument of the
 * corresponding 'rp' type.  Different compilers have different rules with
 * regard to type matching in the presence of 'restrict'.  For backward
 * compatibility libpng callbacks never have 'restrict' in their parameters and,
 * consequentially, writing portable application code is extremely difficult if
 * an attempt is made to use 'restrict'.
 */</font>
<font color='#0000FF'>typedef</font> png_struct <font color='#5555FF'>*</font> PNG_RESTRICT png_structrp;
<font color='#0000FF'>typedef</font> <font color='#0000FF'>const</font> png_struct <font color='#5555FF'>*</font> PNG_RESTRICT png_const_structrp;
<font color='#0000FF'>typedef</font> png_info <font color='#5555FF'>*</font> PNG_RESTRICT png_inforp;
<font color='#0000FF'>typedef</font> <font color='#0000FF'>const</font> png_info <font color='#5555FF'>*</font> PNG_RESTRICT png_const_inforp;

<font color='#009900'>/* Three color definitions.  The order of the red, green, and blue, (and the
 * exact size) is not important, although the size of the fields need to
 * be png_byte or png_uint_16 (as defined below).
 */</font>
<font color='#0000FF'>typedef</font> <font color='#0000FF'>struct</font> <b><a name='png_color_struct'></a>png_color_struct</b>
<b>{</b>
   png_byte red;
   png_byte green;
   png_byte blue;
<b>}</b> png_color;
<font color='#0000FF'>typedef</font> png_color <font color='#5555FF'>*</font> png_colorp;
<font color='#0000FF'>typedef</font> <font color='#0000FF'>const</font> png_color <font color='#5555FF'>*</font> png_const_colorp;
<font color='#0000FF'>typedef</font> png_color <font color='#5555FF'>*</font> <font color='#5555FF'>*</font> png_colorpp;

<font color='#0000FF'>typedef</font> <font color='#0000FF'>struct</font> <b><a name='png_color_16_struct'></a>png_color_16_struct</b>
<b>{</b>
   png_byte index;    <font color='#009900'>/* used for palette files */</font>
   png_uint_16 red;   <font color='#009900'>/* for use in red green blue files */</font>
   png_uint_16 green;
   png_uint_16 blue;
   png_uint_16 gray;  <font color='#009900'>/* for use in grayscale files */</font>
<b>}</b> png_color_16;
<font color='#0000FF'>typedef</font> png_color_16 <font color='#5555FF'>*</font> png_color_16p;
<font color='#0000FF'>typedef</font> <font color='#0000FF'>const</font> png_color_16 <font color='#5555FF'>*</font> png_const_color_16p;
<font color='#0000FF'>typedef</font> png_color_16 <font color='#5555FF'>*</font> <font color='#5555FF'>*</font> png_color_16pp;

<font color='#0000FF'>typedef</font> <font color='#0000FF'>struct</font> <b><a name='png_color_8_struct'></a>png_color_8_struct</b>
<b>{</b>
   png_byte red;   <font color='#009900'>/* for use in red green blue files */</font>
   png_byte green;
   png_byte blue;
   png_byte gray;  <font color='#009900'>/* for use in grayscale files */</font>
   png_byte alpha; <font color='#009900'>/* for alpha channel files */</font>
<b>}</b> png_color_8;
<font color='#0000FF'>typedef</font> png_color_8 <font color='#5555FF'>*</font> png_color_8p;
<font color='#0000FF'>typedef</font> <font color='#0000FF'>const</font> png_color_8 <font color='#5555FF'>*</font> png_const_color_8p;
<font color='#0000FF'>typedef</font> png_color_8 <font color='#5555FF'>*</font> <font color='#5555FF'>*</font> png_color_8pp;

<font color='#009900'>/*
 * The following two structures are used for the in-core representation
 * of sPLT chunks.
 */</font>
<font color='#0000FF'>typedef</font> <font color='#0000FF'>struct</font> <b><a name='png_sPLT_entry_struct'></a>png_sPLT_entry_struct</b>
<b>{</b>
   png_uint_16 red;
   png_uint_16 green;
   png_uint_16 blue;
   png_uint_16 alpha;
   png_uint_16 frequency;
<b>}</b> png_sPLT_entry;
<font color='#0000FF'>typedef</font> png_sPLT_entry <font color='#5555FF'>*</font> png_sPLT_entryp;
<font color='#0000FF'>typedef</font> <font color='#0000FF'>const</font> png_sPLT_entry <font color='#5555FF'>*</font> png_const_sPLT_entryp;
<font color='#0000FF'>typedef</font> png_sPLT_entry <font color='#5555FF'>*</font> <font color='#5555FF'>*</font> png_sPLT_entrypp;

<font color='#009900'>/*  When the depth of the sPLT palette is 8 bits, the color and alpha samples
 *  occupy the LSB of their respective members, and the MSB of each member
 *  is zero-filled.  The frequency member always occupies the full 16 bits.
 */</font>

<font color='#0000FF'>typedef</font> <font color='#0000FF'>struct</font> <b><a name='png_sPLT_struct'></a>png_sPLT_struct</b>
<b>{</b>
   png_charp name;           <font color='#009900'>/* palette name */</font>
   png_byte depth;           <font color='#009900'>/* depth of palette samples */</font>
   png_sPLT_entryp entries;  <font color='#009900'>/* palette entries */</font>
   png_int_32 nentries;      <font color='#009900'>/* number of palette entries */</font>
<b>}</b> png_sPLT_t;
<font color='#0000FF'>typedef</font> png_sPLT_t <font color='#5555FF'>*</font> png_sPLT_tp;
<font color='#0000FF'>typedef</font> <font color='#0000FF'>const</font> png_sPLT_t <font color='#5555FF'>*</font> png_const_sPLT_tp;
<font color='#0000FF'>typedef</font> png_sPLT_t <font color='#5555FF'>*</font> <font color='#5555FF'>*</font> png_sPLT_tpp;

<font color='#0000FF'>#ifdef</font> PNG_TEXT_SUPPORTED
<font color='#009900'>/* png_text holds the contents of a text/ztxt/itxt chunk in a PNG file,
 * and whether that contents is compressed or not.  The "key" field
 * points to a regular zero-terminated C string.  The "text" fields can be a
 * regular C string, an empty string, or a NULL pointer.
 * However, the structure returned by png_get_text() will always contain
 * the "text" field as a regular zero-terminated C string (possibly
 * empty), never a NULL pointer, so it can be safely used in printf() and
 * other string-handling functions.  Note that the "itxt_length", "lang", and
 * "lang_key" members of the structure only exist when the library is built
 * with iTXt chunk support.  Prior to libpng-1.4.0 the library was built by
 * default without iTXt support. Also note that when iTXt *is* supported,
 * the "lang" and "lang_key" fields contain NULL pointers when the
 * "compression" field contains * PNG_TEXT_COMPRESSION_NONE or
 * PNG_TEXT_COMPRESSION_zTXt. Note that the "compression value" is not the
 * same as what appears in the PNG tEXt/zTXt/iTXt chunk's "compression flag"
 * which is always 0 or 1, or its "compression method" which is always 0.
 */</font>
<font color='#0000FF'>typedef</font> <font color='#0000FF'>struct</font> <b><a name='png_text_struct'></a>png_text_struct</b>
<b>{</b>
   <font color='#0000FF'><u>int</u></font>  compression;       <font color='#009900'>/* compression value:
                             -1: tEXt, none
                              0: zTXt, deflate
                              1: iTXt, none
                              2: iTXt, deflate  */</font>
   png_charp key;          <font color='#009900'>/* keyword, 1-79 character description of "text" */</font>
   png_charp text;         <font color='#009900'>/* comment, may be an empty string (ie "")
                              or a NULL pointer */</font>
   png_size_t text_length; <font color='#009900'>/* length of the text string */</font>
   png_size_t itxt_length; <font color='#009900'>/* length of the itxt string */</font>
   png_charp lang;         <font color='#009900'>/* language code, 0-79 characters
                              or a NULL pointer */</font>
   png_charp lang_key;     <font color='#009900'>/* keyword translated UTF-8 string, 0 or more
                              chars or a NULL pointer */</font>
<b>}</b> png_text;
<font color='#0000FF'>typedef</font> png_text <font color='#5555FF'>*</font> png_textp;
<font color='#0000FF'>typedef</font> <font color='#0000FF'>const</font> png_text <font color='#5555FF'>*</font> png_const_textp;
<font color='#0000FF'>typedef</font> png_text <font color='#5555FF'>*</font> <font color='#5555FF'>*</font> png_textpp;
<font color='#0000FF'>#endif</font>

<font color='#009900'>/* Supported compression types for text in PNG files (tEXt, and zTXt).
 * The values of the PNG_TEXT_COMPRESSION_ defines should NOT be changed. */</font>
<font color='#0000FF'>#define</font> PNG_TEXT_COMPRESSION_NONE_WR <font color='#5555FF'>-</font><font color='#979000'>3</font>
<font color='#0000FF'>#define</font> PNG_TEXT_COMPRESSION_zTXt_WR <font color='#5555FF'>-</font><font color='#979000'>2</font>
<font color='#0000FF'>#define</font> PNG_TEXT_COMPRESSION_NONE    <font color='#5555FF'>-</font><font color='#979000'>1</font>
<font color='#0000FF'>#define</font> PNG_TEXT_COMPRESSION_zTXt     <font color='#979000'>0</font>
<font color='#0000FF'>#define</font> PNG_ITXT_COMPRESSION_NONE     <font color='#979000'>1</font>
<font color='#0000FF'>#define</font> PNG_ITXT_COMPRESSION_zTXt     <font color='#979000'>2</font>
<font color='#0000FF'>#define</font> PNG_TEXT_COMPRESSION_LAST     <font color='#979000'>3</font>  <font color='#009900'>/* Not a valid value */</font>

<font color='#009900'>/* png_time is a way to hold the time in an machine independent way.
 * Two conversions are provided, both from time_t and struct tm.  There
 * is no portable way to convert to either of these structures, as far
 * as I know.  If you know of a portable way, send it to me.  As a side
 * note - PNG has always been Year 2000 compliant!
 */</font>
<font color='#0000FF'>typedef</font> <font color='#0000FF'>struct</font> <b><a name='png_time_struct'></a>png_time_struct</b>
<b>{</b>
   png_uint_16 year; <font color='#009900'>/* full year, as in, 1995 */</font>
   png_byte month;   <font color='#009900'>/* month of year, 1 - 12 */</font>
   png_byte day;     <font color='#009900'>/* day of month, 1 - 31 */</font>
   png_byte hour;    <font color='#009900'>/* hour of day, 0 - 23 */</font>
   png_byte minute;  <font color='#009900'>/* minute of hour, 0 - 59 */</font>
   png_byte second;  <font color='#009900'>/* second of minute, 0 - 60 (for leap seconds) */</font>
<b>}</b> png_time;
<font color='#0000FF'>typedef</font> png_time <font color='#5555FF'>*</font> png_timep;
<font color='#0000FF'>typedef</font> <font color='#0000FF'>const</font> png_time <font color='#5555FF'>*</font> png_const_timep;
<font color='#0000FF'>typedef</font> png_time <font color='#5555FF'>*</font> <font color='#5555FF'>*</font> png_timepp;

<font color='#0000FF'>#if</font> defined<font face='Lucida Console'>(</font>PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED<font face='Lucida Console'>)</font> <font color='#5555FF'>|</font><font color='#5555FF'>|</font>\
   <b><a name='defined'></a>defined</b><font face='Lucida Console'>(</font>PNG_USER_CHUNKS_SUPPORTED<font face='Lucida Console'>)</font>
<font color='#009900'>/* png_unknown_chunk is a structure to hold queued chunks for which there is
 * no specific support.  The idea is that we can use this to queue
 * up private chunks for output even though the library doesn't actually
 * know about their semantics.
 *
 * The data in the structure is set by libpng on read and used on write.
 */</font>
<font color='#0000FF'>typedef</font> <font color='#0000FF'>struct</font> <b><a name='png_unknown_chunk_t'></a>png_unknown_chunk_t</b>
<b>{</b>
    png_byte name[<font color='#979000'>5</font>]; <font color='#009900'>/* Textual chunk name with '\0' terminator */</font>
    png_byte <font color='#5555FF'>*</font>data;   <font color='#009900'>/* Data, should not be modified on read! */</font>
    png_size_t size;

    <font color='#009900'>/* On write 'location' must be set using the flag values listed below.
     * Notice that on read it is set by libpng however the values stored have
     * more bits set than are listed below.  Always treat the value as a
     * bitmask.  On write set only one bit - setting multiple bits may cause the
     * chunk to be written in multiple places.
     */</font>
    png_byte location; <font color='#009900'>/* mode of operation at read time */</font>
<b>}</b>
png_unknown_chunk;

<font color='#0000FF'>typedef</font> png_unknown_chunk <font color='#5555FF'>*</font> png_unknown_chunkp;
<font color='#0000FF'>typedef</font> <font color='#0000FF'>const</font> png_unknown_chunk <font color='#5555FF'>*</font> png_const_unknown_chunkp;
<font color='#0000FF'>typedef</font> png_unknown_chunk <font color='#5555FF'>*</font> <font color='#5555FF'>*</font> png_unknown_chunkpp;
<font color='#0000FF'>#endif</font>

<font color='#009900'>/* Flag values for the unknown chunk location byte. */</font>
<font color='#0000FF'>#define</font> PNG_HAVE_IHDR  <font color='#979000'>0x01</font>
<font color='#0000FF'>#define</font> PNG_HAVE_PLTE  <font color='#979000'>0x02</font>
<font color='#0000FF'>#define</font> PNG_AFTER_IDAT <font color='#979000'>0x08</font>

<font color='#009900'>/* Maximum positive integer used in PNG is (2^31)-1 */</font>
<font color='#0000FF'>#define</font> PNG_UINT_31_MAX <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>png_uint_32<font face='Lucida Console'>)</font><font color='#979000'>0x7fffffffL</font><font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PNG_UINT_32_MAX <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>png_uint_32<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font><font color='#5555FF'>-</font><font color='#979000'>1</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PNG_SIZE_MAX <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>png_size_t<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font><font color='#5555FF'>-</font><font color='#979000'>1</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>

<font color='#009900'>/* These are constants for fixed point values encoded in the
 * PNG specification manner (x100000)
 */</font>
<font color='#0000FF'>#define</font> PNG_FP_1    <font color='#979000'>100000</font>
<font color='#0000FF'>#define</font> PNG_FP_HALF  <font color='#979000'>50000</font>
<font color='#0000FF'>#define</font> PNG_FP_MAX  <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>png_fixed_point<font face='Lucida Console'>)</font><font color='#979000'>0x7fffffffL</font><font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PNG_FP_MIN  <font face='Lucida Console'>(</font><font color='#5555FF'>-</font>PNG_FP_MAX<font face='Lucida Console'>)</font>

<font color='#009900'>/* These describe the color_type field in png_info. */</font>
<font color='#009900'>/* color type masks */</font>
<font color='#0000FF'>#define</font> PNG_COLOR_MASK_PALETTE    <font color='#979000'>1</font>
<font color='#0000FF'>#define</font> PNG_COLOR_MASK_COLOR      <font color='#979000'>2</font>
<font color='#0000FF'>#define</font> PNG_COLOR_MASK_ALPHA      <font color='#979000'>4</font>

<font color='#009900'>/* color types.  Note that not all combinations are legal */</font>
<font color='#0000FF'>#define</font> PNG_COLOR_TYPE_GRAY <font color='#979000'>0</font>
<font color='#0000FF'>#define</font> PNG_COLOR_TYPE_PALETTE  <font face='Lucida Console'>(</font>PNG_COLOR_MASK_COLOR <font color='#5555FF'>|</font> PNG_COLOR_MASK_PALETTE<font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PNG_COLOR_TYPE_RGB        <font face='Lucida Console'>(</font>PNG_COLOR_MASK_COLOR<font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PNG_COLOR_TYPE_RGB_ALPHA  <font face='Lucida Console'>(</font>PNG_COLOR_MASK_COLOR <font color='#5555FF'>|</font> PNG_COLOR_MASK_ALPHA<font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PNG_COLOR_TYPE_GRAY_ALPHA <font face='Lucida Console'>(</font>PNG_COLOR_MASK_ALPHA<font face='Lucida Console'>)</font>
<font color='#009900'>/* aliases */</font>
<font color='#0000FF'>#define</font> PNG_COLOR_TYPE_RGBA  PNG_COLOR_TYPE_RGB_ALPHA
<font color='#0000FF'>#define</font> PNG_COLOR_TYPE_GA  PNG_COLOR_TYPE_GRAY_ALPHA

<font color='#009900'>/* This is for compression type. PNG 1.0-1.2 only define the single type. */</font>
<font color='#0000FF'>#define</font> PNG_COMPRESSION_TYPE_BASE <font color='#979000'>0</font> <font color='#009900'>/* Deflate method 8, 32K window */</font>
<font color='#0000FF'>#define</font> PNG_COMPRESSION_TYPE_DEFAULT PNG_COMPRESSION_TYPE_BASE

<font color='#009900'>/* This is for filter type. PNG 1.0-1.2 only define the single type. */</font>
<font color='#0000FF'>#define</font> PNG_FILTER_TYPE_BASE      <font color='#979000'>0</font> <font color='#009900'>/* Single row per-byte filtering */</font>
<font color='#0000FF'>#define</font> PNG_INTRAPIXEL_DIFFERENCING <font color='#979000'>64</font> <font color='#009900'>/* Used only in MNG datastreams */</font>
<font color='#0000FF'>#define</font> PNG_FILTER_TYPE_DEFAULT   PNG_FILTER_TYPE_BASE

<font color='#009900'>/* These are for the interlacing type.  These values should NOT be changed. */</font>
<font color='#0000FF'>#define</font> PNG_INTERLACE_NONE        <font color='#979000'>0</font> <font color='#009900'>/* Non-interlaced image */</font>
<font color='#0000FF'>#define</font> PNG_INTERLACE_ADAM7       <font color='#979000'>1</font> <font color='#009900'>/* Adam7 interlacing */</font>
<font color='#0000FF'>#define</font> PNG_INTERLACE_LAST        <font color='#979000'>2</font> <font color='#009900'>/* Not a valid value */</font>

<font color='#009900'>/* These are for the oFFs chunk.  These values should NOT be changed. */</font>
<font color='#0000FF'>#define</font> PNG_OFFSET_PIXEL          <font color='#979000'>0</font> <font color='#009900'>/* Offset in pixels */</font>
<font color='#0000FF'>#define</font> PNG_OFFSET_MICROMETER     <font color='#979000'>1</font> <font color='#009900'>/* Offset in micrometers (1/10^6 meter) */</font>
<font color='#0000FF'>#define</font> PNG_OFFSET_LAST           <font color='#979000'>2</font> <font color='#009900'>/* Not a valid value */</font>

<font color='#009900'>/* These are for the pCAL chunk.  These values should NOT be changed. */</font>
<font color='#0000FF'>#define</font> PNG_EQUATION_LINEAR       <font color='#979000'>0</font> <font color='#009900'>/* Linear transformation */</font>
<font color='#0000FF'>#define</font> PNG_EQUATION_BASE_E       <font color='#979000'>1</font> <font color='#009900'>/* Exponential base e transform */</font>
<font color='#0000FF'>#define</font> PNG_EQUATION_ARBITRARY    <font color='#979000'>2</font> <font color='#009900'>/* Arbitrary base exponential transform */</font>
<font color='#0000FF'>#define</font> PNG_EQUATION_HYPERBOLIC   <font color='#979000'>3</font> <font color='#009900'>/* Hyperbolic sine transformation */</font>
<font color='#0000FF'>#define</font> PNG_EQUATION_LAST         <font color='#979000'>4</font> <font color='#009900'>/* Not a valid value */</font>

<font color='#009900'>/* These are for the sCAL chunk.  These values should NOT be changed. */</font>
<font color='#0000FF'>#define</font> PNG_SCALE_UNKNOWN         <font color='#979000'>0</font> <font color='#009900'>/* unknown unit (image scale) */</font>
<font color='#0000FF'>#define</font> PNG_SCALE_METER           <font color='#979000'>1</font> <font color='#009900'>/* meters per pixel */</font>
<font color='#0000FF'>#define</font> PNG_SCALE_RADIAN          <font color='#979000'>2</font> <font color='#009900'>/* radians per pixel */</font>
<font color='#0000FF'>#define</font> PNG_SCALE_LAST            <font color='#979000'>3</font> <font color='#009900'>/* Not a valid value */</font>

<font color='#009900'>/* These are for the pHYs chunk.  These values should NOT be changed. */</font>
<font color='#0000FF'>#define</font> PNG_RESOLUTION_UNKNOWN    <font color='#979000'>0</font> <font color='#009900'>/* pixels/unknown unit (aspect ratio) */</font>
<font color='#0000FF'>#define</font> PNG_RESOLUTION_METER      <font color='#979000'>1</font> <font color='#009900'>/* pixels/meter */</font>
<font color='#0000FF'>#define</font> PNG_RESOLUTION_LAST       <font color='#979000'>2</font> <font color='#009900'>/* Not a valid value */</font>

<font color='#009900'>/* These are for the sRGB chunk.  These values should NOT be changed. */</font>
<font color='#0000FF'>#define</font> PNG_sRGB_INTENT_PERCEPTUAL <font color='#979000'>0</font>
<font color='#0000FF'>#define</font> PNG_sRGB_INTENT_RELATIVE   <font color='#979000'>1</font>
<font color='#0000FF'>#define</font> PNG_sRGB_INTENT_SATURATION <font color='#979000'>2</font>
<font color='#0000FF'>#define</font> PNG_sRGB_INTENT_ABSOLUTE   <font color='#979000'>3</font>
<font color='#0000FF'>#define</font> PNG_sRGB_INTENT_LAST       <font color='#979000'>4</font> <font color='#009900'>/* Not a valid value */</font>

<font color='#009900'>/* This is for text chunks */</font>
<font color='#0000FF'>#define</font> PNG_KEYWORD_MAX_LENGTH     <font color='#979000'>79</font>

<font color='#009900'>/* Maximum number of entries in PLTE/sPLT/tRNS arrays */</font>
<font color='#0000FF'>#define</font> PNG_MAX_PALETTE_LENGTH    <font color='#979000'>256</font>

<font color='#009900'>/* These determine if an ancillary chunk's data has been successfully read
 * from the PNG header, or if the application has filled in the corresponding
 * data in the info_struct to be written into the output file.  The values
 * of the PNG_INFO_&lt;chunk&gt; defines should NOT be changed.
 */</font>
<font color='#0000FF'>#define</font> PNG_INFO_gAMA <font color='#979000'>0x0001</font>
<font color='#0000FF'>#define</font> PNG_INFO_sBIT <font color='#979000'>0x0002</font>
<font color='#0000FF'>#define</font> PNG_INFO_cHRM <font color='#979000'>0x0004</font>
<font color='#0000FF'>#define</font> PNG_INFO_PLTE <font color='#979000'>0x0008</font>
<font color='#0000FF'>#define</font> PNG_INFO_tRNS <font color='#979000'>0x0010</font>
<font color='#0000FF'>#define</font> PNG_INFO_bKGD <font color='#979000'>0x0020</font>
<font color='#0000FF'>#define</font> PNG_INFO_hIST <font color='#979000'>0x0040</font>
<font color='#0000FF'>#define</font> PNG_INFO_pHYs <font color='#979000'>0x0080</font>
<font color='#0000FF'>#define</font> PNG_INFO_oFFs <font color='#979000'>0x0100</font>
<font color='#0000FF'>#define</font> PNG_INFO_tIME <font color='#979000'>0x0200</font>
<font color='#0000FF'>#define</font> PNG_INFO_pCAL <font color='#979000'>0x0400</font>
<font color='#0000FF'>#define</font> PNG_INFO_sRGB <font color='#979000'>0x0800</font>   <font color='#009900'>/* GR-P, 0.96a */</font>
<font color='#0000FF'>#define</font> PNG_INFO_iCCP <font color='#979000'>0x1000</font>   <font color='#009900'>/* ESR, 1.0.6 */</font>
<font color='#0000FF'>#define</font> PNG_INFO_sPLT <font color='#979000'>0x2000</font>   <font color='#009900'>/* ESR, 1.0.6 */</font>
<font color='#0000FF'>#define</font> PNG_INFO_sCAL <font color='#979000'>0x4000</font>   <font color='#009900'>/* ESR, 1.0.6 */</font>
<font color='#0000FF'>#define</font> PNG_INFO_IDAT <font color='#979000'>0x8000</font>   <font color='#009900'>/* ESR, 1.0.6 */</font>

<font color='#009900'>/* This is used for the transformation routines, as some of them
 * change these values for the row.  It also should enable using
 * the routines for other purposes.
 */</font>
<font color='#0000FF'>typedef</font> <font color='#0000FF'>struct</font> <b><a name='png_row_info_struct'></a>png_row_info_struct</b>
<b>{</b>
   png_uint_32 width;    <font color='#009900'>/* width of row */</font>
   png_size_t rowbytes;  <font color='#009900'>/* number of bytes in row */</font>
   png_byte color_type;  <font color='#009900'>/* color type of row */</font>
   png_byte bit_depth;   <font color='#009900'>/* bit depth of row */</font>
   png_byte channels;    <font color='#009900'>/* number of channels (1, 2, 3, or 4) */</font>
   png_byte pixel_depth; <font color='#009900'>/* bits per pixel (depth * channels) */</font>
<b>}</b> png_row_info;

<font color='#0000FF'>typedef</font> png_row_info <font color='#5555FF'>*</font> png_row_infop;
<font color='#0000FF'>typedef</font> png_row_info <font color='#5555FF'>*</font> <font color='#5555FF'>*</font> png_row_infopp;

<font color='#009900'>/* These are the function types for the I/O functions and for the functions
 * that allow the user to override the default I/O functions with his or her
 * own.  The png_error_ptr type should match that of user-supplied warning
 * and error functions, while the png_rw_ptr type should match that of the
 * user read/write data functions.  Note that the 'write' function must not
 * modify the buffer it is passed. The 'read' function, on the other hand, is
 * expected to return the read data in the buffer.
 */</font>
<font color='#0000FF'>typedef</font> <b><a name='PNG_CALLBACK'></a>PNG_CALLBACK</b><font face='Lucida Console'>(</font><font color='#0000FF'><u>void</u></font>, <font color='#5555FF'>*</font>png_error_ptr, <font face='Lucida Console'>(</font>png_structp, png_const_charp<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>typedef</font> <b><a name='PNG_CALLBACK'></a>PNG_CALLBACK</b><font face='Lucida Console'>(</font><font color='#0000FF'><u>void</u></font>, <font color='#5555FF'>*</font>png_rw_ptr, <font face='Lucida Console'>(</font>png_structp, png_bytep, png_size_t<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>typedef</font> <b><a name='PNG_CALLBACK'></a>PNG_CALLBACK</b><font face='Lucida Console'>(</font><font color='#0000FF'><u>void</u></font>, <font color='#5555FF'>*</font>png_flush_ptr, <font face='Lucida Console'>(</font>png_structp<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>typedef</font> <b><a name='PNG_CALLBACK'></a>PNG_CALLBACK</b><font face='Lucida Console'>(</font><font color='#0000FF'><u>void</u></font>, <font color='#5555FF'>*</font>png_read_status_ptr, <font face='Lucida Console'>(</font>png_structp, png_uint_32,
    <font color='#0000FF'><u>int</u></font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>typedef</font> <b><a name='PNG_CALLBACK'></a>PNG_CALLBACK</b><font face='Lucida Console'>(</font><font color='#0000FF'><u>void</u></font>, <font color='#5555FF'>*</font>png_write_status_ptr, <font face='Lucida Console'>(</font>png_structp, png_uint_32,
    <font color='#0000FF'><u>int</u></font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#0000FF'>#ifdef</font> PNG_PROGRESSIVE_READ_SUPPORTED
<font color='#0000FF'>typedef</font> <b><a name='PNG_CALLBACK'></a>PNG_CALLBACK</b><font face='Lucida Console'>(</font><font color='#0000FF'><u>void</u></font>, <font color='#5555FF'>*</font>png_progressive_info_ptr, <font face='Lucida Console'>(</font>png_structp, png_infop<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>typedef</font> <b><a name='PNG_CALLBACK'></a>PNG_CALLBACK</b><font face='Lucida Console'>(</font><font color='#0000FF'><u>void</u></font>, <font color='#5555FF'>*</font>png_progressive_end_ptr, <font face='Lucida Console'>(</font>png_structp, png_infop<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* The following callback receives png_uint_32 row_number, int pass for the
 * png_bytep data of the row.  When transforming an interlaced image the
 * row number is the row number within the sub-image of the interlace pass, so
 * the value will increase to the height of the sub-image (not the full image)
 * then reset to 0 for the next pass.
 *
 * Use PNG_ROW_FROM_PASS_ROW(row, pass) and PNG_COL_FROM_PASS_COL(col, pass) to
 * find the output pixel (x,y) given an interlaced sub-image pixel
 * (row,col,pass).  (See below for these macros.)
 */</font>
<font color='#0000FF'>typedef</font> <b><a name='PNG_CALLBACK'></a>PNG_CALLBACK</b><font face='Lucida Console'>(</font><font color='#0000FF'><u>void</u></font>, <font color='#5555FF'>*</font>png_progressive_row_ptr, <font face='Lucida Console'>(</font>png_structp, png_bytep,
    png_uint_32, <font color='#0000FF'><u>int</u></font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#if</font> defined<font face='Lucida Console'>(</font>PNG_READ_USER_TRANSFORM_SUPPORTED<font face='Lucida Console'>)</font> <font color='#5555FF'>|</font><font color='#5555FF'>|</font> \
    <b><a name='defined'></a>defined</b><font face='Lucida Console'>(</font>PNG_WRITE_USER_TRANSFORM_SUPPORTED<font face='Lucida Console'>)</font>
<font color='#0000FF'>typedef</font> <b><a name='PNG_CALLBACK'></a>PNG_CALLBACK</b><font face='Lucida Console'>(</font><font color='#0000FF'><u>void</u></font>, <font color='#5555FF'>*</font>png_user_transform_ptr, <font face='Lucida Console'>(</font>png_structp, png_row_infop,
    png_bytep<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_USER_CHUNKS_SUPPORTED
<font color='#0000FF'>typedef</font> <b><a name='PNG_CALLBACK'></a>PNG_CALLBACK</b><font face='Lucida Console'>(</font><font color='#0000FF'><u>int</u></font>, <font color='#5555FF'>*</font>png_user_chunk_ptr, <font face='Lucida Console'>(</font>png_structp,
    png_unknown_chunkp<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>
<font color='#0000FF'>#ifdef</font> PNG_UNKNOWN_CHUNKS_SUPPORTED
<font color='#009900'>/* not used anywhere */</font>
<font color='#009900'>/* typedef PNG_CALLBACK(void, *png_unknown_chunk_ptr, (png_structp)); */</font>
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_SETJMP_SUPPORTED
<font color='#009900'>/* This must match the function definition in &lt;setjmp.h&gt;, and the application
 * must include this before png.h to obtain the definition of jmp_buf.  The
 * function is required to be PNG_NORETURN, but this is not checked.  If the
 * function does return the application will crash via an abort() or similar
 * system level call.
 *
 * If you get a warning here while building the library you may need to make
 * changes to ensure that pnglibconf.h records the calling convention used by
 * your compiler.  This may be very difficult - try using a different compiler
 * to build the library!
 */</font>
<b><a name='PNG_FUNCTION'></a>PNG_FUNCTION</b><font face='Lucida Console'>(</font><font color='#0000FF'><u>void</u></font>, <font face='Lucida Console'>(</font>PNGCAPI <font color='#5555FF'>*</font>png_longjmp_ptr<font face='Lucida Console'>)</font>, <font color='#BB00BB'>PNGARG</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>jmp_buf, <font color='#0000FF'><u>int</u></font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>, <font color='#0000FF'>typedef</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#009900'>/* Transform masks for the high-level interface */</font>
<font color='#0000FF'>#define</font> PNG_TRANSFORM_IDENTITY       <font color='#979000'>0x0000</font>    <font color='#009900'>/* read and write */</font>
<font color='#0000FF'>#define</font> PNG_TRANSFORM_STRIP_16       <font color='#979000'>0x0001</font>    <font color='#009900'>/* read only */</font>
<font color='#0000FF'>#define</font> PNG_TRANSFORM_STRIP_ALPHA    <font color='#979000'>0x0002</font>    <font color='#009900'>/* read only */</font>
<font color='#0000FF'>#define</font> PNG_TRANSFORM_PACKING        <font color='#979000'>0x0004</font>    <font color='#009900'>/* read and write */</font>
<font color='#0000FF'>#define</font> PNG_TRANSFORM_PACKSWAP       <font color='#979000'>0x0008</font>    <font color='#009900'>/* read and write */</font>
<font color='#0000FF'>#define</font> PNG_TRANSFORM_EXPAND         <font color='#979000'>0x0010</font>    <font color='#009900'>/* read only */</font>
<font color='#0000FF'>#define</font> PNG_TRANSFORM_INVERT_MONO    <font color='#979000'>0x0020</font>    <font color='#009900'>/* read and write */</font>
<font color='#0000FF'>#define</font> PNG_TRANSFORM_SHIFT          <font color='#979000'>0x0040</font>    <font color='#009900'>/* read and write */</font>
<font color='#0000FF'>#define</font> PNG_TRANSFORM_BGR            <font color='#979000'>0x0080</font>    <font color='#009900'>/* read and write */</font>
<font color='#0000FF'>#define</font> PNG_TRANSFORM_SWAP_ALPHA     <font color='#979000'>0x0100</font>    <font color='#009900'>/* read and write */</font>
<font color='#0000FF'>#define</font> PNG_TRANSFORM_SWAP_ENDIAN    <font color='#979000'>0x0200</font>    <font color='#009900'>/* read and write */</font>
<font color='#0000FF'>#define</font> PNG_TRANSFORM_INVERT_ALPHA   <font color='#979000'>0x0400</font>    <font color='#009900'>/* read and write */</font>
<font color='#0000FF'>#define</font> PNG_TRANSFORM_STRIP_FILLER   <font color='#979000'>0x0800</font>    <font color='#009900'>/* write only */</font>
<font color='#009900'>/* Added to libpng-1.2.34 */</font>
<font color='#0000FF'>#define</font> PNG_TRANSFORM_STRIP_FILLER_BEFORE PNG_TRANSFORM_STRIP_FILLER
<font color='#0000FF'>#define</font> PNG_TRANSFORM_STRIP_FILLER_AFTER <font color='#979000'>0x1000</font> <font color='#009900'>/* write only */</font>
<font color='#009900'>/* Added to libpng-1.4.0 */</font>
<font color='#0000FF'>#define</font> PNG_TRANSFORM_GRAY_TO_RGB   <font color='#979000'>0x2000</font>      <font color='#009900'>/* read only */</font>
<font color='#009900'>/* Added to libpng-1.5.4 */</font>
<font color='#0000FF'>#define</font> PNG_TRANSFORM_EXPAND_16     <font color='#979000'>0x4000</font>      <font color='#009900'>/* read only */</font>
<font color='#0000FF'>#define</font> PNG_TRANSFORM_SCALE_16      <font color='#979000'>0x8000</font>      <font color='#009900'>/* read only */</font>

<font color='#009900'>/* Flags for MNG supported features */</font>
<font color='#0000FF'>#define</font> PNG_FLAG_MNG_EMPTY_PLTE     <font color='#979000'>0x01</font>
<font color='#0000FF'>#define</font> PNG_FLAG_MNG_FILTER_64      <font color='#979000'>0x04</font>
<font color='#0000FF'>#define</font> PNG_ALL_MNG_FEATURES        <font color='#979000'>0x05</font>

<font color='#009900'>/* NOTE: prior to 1.5 these functions had no 'API' style declaration,
 * this allowed the zlib default functions to be used on Windows
 * platforms.  In 1.5 the zlib default malloc (which just calls malloc and
 * ignores the first argument) should be completely compatible with the
 * following.
 */</font>
<font color='#0000FF'>typedef</font> <b><a name='PNG_CALLBACK'></a>PNG_CALLBACK</b><font face='Lucida Console'>(</font>png_voidp, <font color='#5555FF'>*</font>png_malloc_ptr, <font face='Lucida Console'>(</font>png_structp,
    png_alloc_size_t<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>typedef</font> <b><a name='PNG_CALLBACK'></a>PNG_CALLBACK</b><font face='Lucida Console'>(</font><font color='#0000FF'><u>void</u></font>, <font color='#5555FF'>*</font>png_free_ptr, <font face='Lucida Console'>(</font>png_structp, png_voidp<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Section 3: exported functions
 * Here are the function definitions most commonly used.  This is not
 * the place to find out how to use libpng.  See libpng-manual.txt for the
 * full explanation, see example.c for the summary.  This just provides
 * a simple one line description of the use of each function.
 *
 * The PNG_EXPORT() and PNG_EXPORTA() macros used below are defined in
 * pngconf.h and in the *.dfn files in the scripts directory.
 *
 *   PNG_EXPORT(ordinal, type, name, (args));
 *
 *       ordinal:    ordinal that is used while building
 *                   *.def files. The ordinal value is only
 *                   relevant when preprocessing png.h with
 *                   the *.dfn files for building symbol table
 *                   entries, and are removed by pngconf.h.
 *       type:       return type of the function
 *       name:       function name
 *       args:       function arguments, with types
 *
 * When we wish to append attributes to a function prototype we use
 * the PNG_EXPORTA() macro instead.
 *
 *   PNG_EXPORTA(ordinal, type, name, (args), attributes);
 *
 *       ordinal, type, name, and args: same as in PNG_EXPORT().
 *       attributes: function attributes
 */</font>

<font color='#009900'>/* Returns the version number of the library */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>1</font>, png_uint_32, png_access_version_number, <font face='Lucida Console'>(</font><font color='#0000FF'><u>void</u></font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Tell lib we have already handled the first &lt;num_bytes&gt; magic bytes.
 * Handling more than 8 bytes from the beginning of the file is an error.
 */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>2</font>, <font color='#0000FF'><u>void</u></font>, png_set_sig_bytes, <font face='Lucida Console'>(</font>png_structrp png_ptr, <font color='#0000FF'><u>int</u></font> num_bytes<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Check sig[start] through sig[start + num_to_check - 1] to see if it's a
 * PNG file.  Returns zero if the supplied bytes match the 8-byte PNG
 * signature, and non-zero otherwise.  Having num_to_check == 0 or
 * start &gt; 7 will always fail (ie return non-zero).
 */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>3</font>, <font color='#0000FF'><u>int</u></font>, png_sig_cmp, <font face='Lucida Console'>(</font>png_const_bytep sig, png_size_t start,
    png_size_t num_to_check<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Simple signature checking function.  This is the same as calling
 * png_check_sig(sig, n) := !png_sig_cmp(sig, 0, n).
 */</font>
<font color='#0000FF'>#define</font> png_check_sig<font face='Lucida Console'>(</font>sig, n<font face='Lucida Console'>)</font> <font color='#5555FF'>!</font>png_sig_cmp<font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>sig<font face='Lucida Console'>)</font>, <font color='#979000'>0</font>, <font face='Lucida Console'>(</font>n<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>

<font color='#009900'>/* Allocate and initialize png_ptr struct for reading, and any other memory. */</font>
<b><a name='PNG_EXPORTA'></a>PNG_EXPORTA</b><font face='Lucida Console'>(</font><font color='#979000'>4</font>, png_structp, png_create_read_struct,
    <font face='Lucida Console'>(</font>png_const_charp user_png_ver, png_voidp error_ptr,
    png_error_ptr error_fn, png_error_ptr warn_fn<font face='Lucida Console'>)</font>,
    PNG_ALLOCATED<font face='Lucida Console'>)</font>;

<font color='#009900'>/* Allocate and initialize png_ptr struct for writing, and any other memory */</font>
<b><a name='PNG_EXPORTA'></a>PNG_EXPORTA</b><font face='Lucida Console'>(</font><font color='#979000'>5</font>, png_structp, png_create_write_struct,
    <font face='Lucida Console'>(</font>png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn,
    png_error_ptr warn_fn<font face='Lucida Console'>)</font>,
    PNG_ALLOCATED<font face='Lucida Console'>)</font>;

<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>6</font>, png_size_t, png_get_compression_buffer_size,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>7</font>, <font color='#0000FF'><u>void</u></font>, png_set_compression_buffer_size, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    png_size_t size<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Moved from pngconf.h in 1.4.0 and modified to ensure setjmp/longjmp
 * match up.
 */</font>
<font color='#0000FF'>#ifdef</font> PNG_SETJMP_SUPPORTED
<font color='#009900'>/* This function returns the jmp_buf built in to *png_ptr.  It must be
 * supplied with an appropriate 'longjmp' function to use on that jmp_buf
 * unless the default error function is overridden in which case NULL is
 * acceptable.  The size of the jmp_buf is checked against the actual size
 * allocated by the library - the call will return NULL on a mismatch
 * indicating an ABI mismatch.
 */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>8</font>, jmp_buf<font color='#5555FF'>*</font>, png_set_longjmp_fn, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    png_longjmp_ptr longjmp_fn, <font color='#0000FF'><u>size_t</u></font> jmp_buf_size<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
#  define <b><a name='png_jmpbuf'></a>png_jmpbuf</b><font face='Lucida Console'>(</font>png_ptr<font face='Lucida Console'>)</font> \
      <font face='Lucida Console'>(</font><font color='#5555FF'>*</font><font color='#BB00BB'>png_set_longjmp_fn</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>png_ptr<font face='Lucida Console'>)</font>, longjmp, <font face='Lucida Console'>(</font><font color='#0000FF'>sizeof</font> <font face='Lucida Console'>(</font>jmp_buf<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<font color='#0000FF'>#else</font>
#  define <b><a name='png_jmpbuf'></a>png_jmpbuf</b><font face='Lucida Console'>(</font>png_ptr<font face='Lucida Console'>)</font> \
      <font face='Lucida Console'>(</font>LIBPNG_WAS_COMPILED_WITH__PNG_NO_SETJMP<font face='Lucida Console'>)</font>
<font color='#0000FF'>#endif</font>
<font color='#009900'>/* This function should be used by libpng applications in place of
 * longjmp(png_ptr-&gt;jmpbuf, val).  If longjmp_fn() has been set, it
 * will use it; otherwise it will call PNG_ABORT().  This function was
 * added in libpng-1.5.0.
 */</font>
<b><a name='PNG_EXPORTA'></a>PNG_EXPORTA</b><font face='Lucida Console'>(</font><font color='#979000'>9</font>, <font color='#0000FF'><u>void</u></font>, png_longjmp, <font face='Lucida Console'>(</font>png_const_structrp png_ptr, <font color='#0000FF'><u>int</u></font> val<font face='Lucida Console'>)</font>,
    PNG_NORETURN<font face='Lucida Console'>)</font>;

<font color='#0000FF'>#ifdef</font> PNG_READ_SUPPORTED
<font color='#009900'>/* Reset the compression stream */</font>
<b><a name='PNG_EXPORTA'></a>PNG_EXPORTA</b><font face='Lucida Console'>(</font><font color='#979000'>10</font>, <font color='#0000FF'><u>int</u></font>, png_reset_zstream, <font face='Lucida Console'>(</font>png_structrp png_ptr<font face='Lucida Console'>)</font>, PNG_DEPRECATED<font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#009900'>/* New functions added in libpng-1.0.2 (not enabled by default until 1.2.0) */</font>
<font color='#0000FF'>#ifdef</font> PNG_USER_MEM_SUPPORTED
<b><a name='PNG_EXPORTA'></a>PNG_EXPORTA</b><font face='Lucida Console'>(</font><font color='#979000'>11</font>, png_structp, png_create_read_struct_2,
    <font face='Lucida Console'>(</font>png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn,
    png_error_ptr warn_fn,
    png_voidp mem_ptr, png_malloc_ptr malloc_fn, png_free_ptr free_fn<font face='Lucida Console'>)</font>,
    PNG_ALLOCATED<font face='Lucida Console'>)</font>;
<b><a name='PNG_EXPORTA'></a>PNG_EXPORTA</b><font face='Lucida Console'>(</font><font color='#979000'>12</font>, png_structp, png_create_write_struct_2,
    <font face='Lucida Console'>(</font>png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn,
    png_error_ptr warn_fn,
    png_voidp mem_ptr, png_malloc_ptr malloc_fn, png_free_ptr free_fn<font face='Lucida Console'>)</font>,
    PNG_ALLOCATED<font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#009900'>/* Write the PNG file signature. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>13</font>, <font color='#0000FF'><u>void</u></font>, png_write_sig, <font face='Lucida Console'>(</font>png_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Write a PNG chunk - size, type, (optional) data, CRC. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>14</font>, <font color='#0000FF'><u>void</u></font>, png_write_chunk, <font face='Lucida Console'>(</font>png_structrp png_ptr, png_const_bytep
    chunk_name, png_const_bytep data, png_size_t length<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Write the start of a PNG chunk - length and chunk name. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>15</font>, <font color='#0000FF'><u>void</u></font>, png_write_chunk_start, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    png_const_bytep chunk_name, png_uint_32 length<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Write the data of a PNG chunk started with png_write_chunk_start(). */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>16</font>, <font color='#0000FF'><u>void</u></font>, png_write_chunk_data, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    png_const_bytep data, png_size_t length<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Finish a chunk started with png_write_chunk_start() (includes CRC). */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>17</font>, <font color='#0000FF'><u>void</u></font>, png_write_chunk_end, <font face='Lucida Console'>(</font>png_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Allocate and initialize the info structure */</font>
<b><a name='PNG_EXPORTA'></a>PNG_EXPORTA</b><font face='Lucida Console'>(</font><font color='#979000'>18</font>, png_infop, png_create_info_struct, <font face='Lucida Console'>(</font>png_const_structrp png_ptr<font face='Lucida Console'>)</font>,
    PNG_ALLOCATED<font face='Lucida Console'>)</font>;

<font color='#009900'>/* DEPRECATED: this function allowed init structures to be created using the
 * default allocation method (typically malloc).  Use is deprecated in 1.6.0 and
 * the API will be removed in the future.
 */</font>
<b><a name='PNG_EXPORTA'></a>PNG_EXPORTA</b><font face='Lucida Console'>(</font><font color='#979000'>19</font>, <font color='#0000FF'><u>void</u></font>, png_info_init_3, <font face='Lucida Console'>(</font>png_infopp info_ptr,
    png_size_t png_info_struct_size<font face='Lucida Console'>)</font>, PNG_DEPRECATED<font face='Lucida Console'>)</font>;

<font color='#009900'>/* Writes all the PNG information before the image. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>20</font>, <font color='#0000FF'><u>void</u></font>, png_write_info_before_PLTE,
    <font face='Lucida Console'>(</font>png_structrp png_ptr, png_const_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>21</font>, <font color='#0000FF'><u>void</u></font>, png_write_info,
    <font face='Lucida Console'>(</font>png_structrp png_ptr, png_const_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#0000FF'>#ifdef</font> PNG_SEQUENTIAL_READ_SUPPORTED
<font color='#009900'>/* Read the information before the actual image data. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>22</font>, <font color='#0000FF'><u>void</u></font>, png_read_info,
    <font face='Lucida Console'>(</font>png_structrp png_ptr, png_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_TIME_RFC1123_SUPPORTED
   <font color='#009900'>/* Convert to a US string format: there is no localization support in this
    * routine.  The original implementation used a 29 character buffer in
    * png_struct, this will be removed in future versions.
    */</font>
<font color='#0000FF'>#if</font> PNG_LIBPNG_VER <font color='#5555FF'>&lt;</font> <font color='#979000'>10700</font>
<font color='#009900'>/* To do: remove this from libpng17 (and from libpng17/png.c and pngstruct.h) */</font>
<b><a name='PNG_EXPORTA'></a>PNG_EXPORTA</b><font face='Lucida Console'>(</font><font color='#979000'>23</font>, png_const_charp, png_convert_to_rfc1123, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    png_const_timep ptime<font face='Lucida Console'>)</font>,PNG_DEPRECATED<font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>241</font>, <font color='#0000FF'><u>int</u></font>, png_convert_to_rfc1123_buffer, <font face='Lucida Console'>(</font><font color='#0000FF'><u>char</u></font> out[<font color='#979000'>29</font>],
    png_const_timep ptime<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_CONVERT_tIME_SUPPORTED
<font color='#009900'>/* Convert from a struct tm to png_time */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>24</font>, <font color='#0000FF'><u>void</u></font>, png_convert_from_struct_tm, <font face='Lucida Console'>(</font>png_timep ptime,
    <font color='#0000FF'>const</font> <font color='#0000FF'>struct</font> tm <font color='#5555FF'>*</font> ttime<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Convert from time_t to png_time.  Uses gmtime() */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>25</font>, <font color='#0000FF'><u>void</u></font>, png_convert_from_time_t, <font face='Lucida Console'>(</font>png_timep ptime, time_t ttime<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font> <font color='#009900'>/* PNG_CONVERT_tIME_SUPPORTED */</font>

<font color='#0000FF'>#ifdef</font> PNG_READ_EXPAND_SUPPORTED
<font color='#009900'>/* Expand data to 24-bit RGB, or 8-bit grayscale, with alpha if available. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>26</font>, <font color='#0000FF'><u>void</u></font>, png_set_expand, <font face='Lucida Console'>(</font>png_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>27</font>, <font color='#0000FF'><u>void</u></font>, png_set_expand_gray_1_2_4_to_8, <font face='Lucida Console'>(</font>png_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>28</font>, <font color='#0000FF'><u>void</u></font>, png_set_palette_to_rgb, <font face='Lucida Console'>(</font>png_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>29</font>, <font color='#0000FF'><u>void</u></font>, png_set_tRNS_to_alpha, <font face='Lucida Console'>(</font>png_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_READ_EXPAND_16_SUPPORTED
<font color='#009900'>/* Expand to 16-bit channels, forces conversion of palette to RGB and expansion
 * of a tRNS chunk if present.
 */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>221</font>, <font color='#0000FF'><u>void</u></font>, png_set_expand_16, <font face='Lucida Console'>(</font>png_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#if</font> defined<font face='Lucida Console'>(</font>PNG_READ_BGR_SUPPORTED<font face='Lucida Console'>)</font> <font color='#5555FF'>|</font><font color='#5555FF'>|</font> defined<font face='Lucida Console'>(</font>PNG_WRITE_BGR_SUPPORTED<font face='Lucida Console'>)</font>
<font color='#009900'>/* Use blue, green, red order for pixels. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>30</font>, <font color='#0000FF'><u>void</u></font>, png_set_bgr, <font face='Lucida Console'>(</font>png_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_READ_GRAY_TO_RGB_SUPPORTED
<font color='#009900'>/* Expand the grayscale to 24-bit RGB if necessary. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>31</font>, <font color='#0000FF'><u>void</u></font>, png_set_gray_to_rgb, <font face='Lucida Console'>(</font>png_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_READ_RGB_TO_GRAY_SUPPORTED
<font color='#009900'>/* Reduce RGB to grayscale. */</font>
<font color='#0000FF'>#define</font> PNG_ERROR_ACTION_NONE  <font color='#979000'>1</font>
<font color='#0000FF'>#define</font> PNG_ERROR_ACTION_WARN  <font color='#979000'>2</font>
<font color='#0000FF'>#define</font> PNG_ERROR_ACTION_ERROR <font color='#979000'>3</font>
<font color='#0000FF'>#define</font> PNG_RGB_TO_GRAY_DEFAULT <font face='Lucida Console'>(</font><font color='#5555FF'>-</font><font color='#979000'>1</font><font face='Lucida Console'>)</font><font color='#009900'>/*for red/green coefficients*/</font>

<b><a name='PNG_FP_EXPORT'></a>PNG_FP_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>32</font>, <font color='#0000FF'><u>void</u></font>, png_set_rgb_to_gray, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    <font color='#0000FF'><u>int</u></font> error_action, <font color='#0000FF'><u>double</u></font> red, <font color='#0000FF'><u>double</u></font> green<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<b><a name='PNG_FIXED_EXPORT'></a>PNG_FIXED_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>33</font>, <font color='#0000FF'><u>void</u></font>, png_set_rgb_to_gray_fixed, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    <font color='#0000FF'><u>int</u></font> error_action, png_fixed_point red, png_fixed_point green<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>

<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>34</font>, png_byte, png_get_rgb_to_gray_status, <font face='Lucida Console'>(</font>png_const_structrp
    png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>35</font>, <font color='#0000FF'><u>void</u></font>, png_build_grayscale_palette, <font face='Lucida Console'>(</font><font color='#0000FF'><u>int</u></font> bit_depth,
    png_colorp palette<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_READ_ALPHA_MODE_SUPPORTED
<font color='#009900'>/* How the alpha channel is interpreted - this affects how the color channels of
 * a PNG file are returned when an alpha channel, or tRNS chunk in a palette
 * file, is present.
 *
 * This has no effect on the way pixels are written into a PNG output
 * datastream. The color samples in a PNG datastream are never premultiplied
 * with the alpha samples.
 *
 * The default is to return data according to the PNG specification: the alpha
 * channel is a linear measure of the contribution of the pixel to the
 * corresponding composited pixel.  The gamma encoded color channels must be
 * scaled according to the contribution and to do this it is necessary to undo
 * the encoding, scale the color values, perform the composition and reencode
 * the values.  This is the 'PNG' mode.
 *
 * The alternative is to 'associate' the alpha with the color information by
 * storing color channel values that have been scaled by the alpha.  The
 * advantage is that the color channels can be resampled (the image can be
 * scaled) in this form.  The disadvantage is that normal practice is to store
 * linear, not (gamma) encoded, values and this requires 16-bit channels for
 * still images rather than the 8-bit channels that are just about sufficient if
 * gamma encoding is used.  In addition all non-transparent pixel values,
 * including completely opaque ones, must be gamma encoded to produce the final
 * image.  This is the 'STANDARD', 'ASSOCIATED' or 'PREMULTIPLIED' mode (the
 * latter being the two common names for associated alpha color channels.)
 *
 * Since it is not necessary to perform arithmetic on opaque color values so
 * long as they are not to be resampled and are in the final color space it is
 * possible to optimize the handling of alpha by storing the opaque pixels in
 * the PNG format (adjusted for the output color space) while storing partially
 * opaque pixels in the standard, linear, format.  The accuracy required for
 * standard alpha composition is relatively low, because the pixels are
 * isolated, therefore typically the accuracy loss in storing 8-bit linear
 * values is acceptable.  (This is not true if the alpha channel is used to
 * simulate transparency over large areas - use 16 bits or the PNG mode in
 * this case!)  This is the 'OPTIMIZED' mode.  For this mode a pixel is
 * treated as opaque only if the alpha value is equal to the maximum value.
 *
 * The final choice is to gamma encode the alpha channel as well.  This is
 * broken because, in practice, no implementation that uses this choice
 * correctly undoes the encoding before handling alpha composition.  Use this
 * choice only if other serious errors in the software or hardware you use
 * mandate it; the typical serious error is for dark halos to appear around
 * opaque areas of the composited PNG image because of arithmetic overflow.
 *
 * The API function png_set_alpha_mode specifies which of these choices to use
 * with an enumerated 'mode' value and the gamma of the required output:
 */</font>
<font color='#0000FF'>#define</font> PNG_ALPHA_PNG           <font color='#979000'>0</font> <font color='#009900'>/* according to the PNG standard */</font>
<font color='#0000FF'>#define</font> PNG_ALPHA_STANDARD      <font color='#979000'>1</font> <font color='#009900'>/* according to Porter/Duff */</font>
<font color='#0000FF'>#define</font> PNG_ALPHA_ASSOCIATED    <font color='#979000'>1</font> <font color='#009900'>/* as above; this is the normal practice */</font>
<font color='#0000FF'>#define</font> PNG_ALPHA_PREMULTIPLIED <font color='#979000'>1</font> <font color='#009900'>/* as above */</font>
<font color='#0000FF'>#define</font> PNG_ALPHA_OPTIMIZED     <font color='#979000'>2</font> <font color='#009900'>/* 'PNG' for opaque pixels, else 'STANDARD' */</font>
<font color='#0000FF'>#define</font> PNG_ALPHA_BROKEN        <font color='#979000'>3</font> <font color='#009900'>/* the alpha channel is gamma encoded */</font>

<b><a name='PNG_FP_EXPORT'></a>PNG_FP_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>227</font>, <font color='#0000FF'><u>void</u></font>, png_set_alpha_mode, <font face='Lucida Console'>(</font>png_structrp png_ptr, <font color='#0000FF'><u>int</u></font> mode,
    <font color='#0000FF'><u>double</u></font> output_gamma<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<b><a name='PNG_FIXED_EXPORT'></a>PNG_FIXED_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>228</font>, <font color='#0000FF'><u>void</u></font>, png_set_alpha_mode_fixed, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    <font color='#0000FF'><u>int</u></font> mode, png_fixed_point output_gamma<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#if</font> defined<font face='Lucida Console'>(</font>PNG_GAMMA_SUPPORTED<font face='Lucida Console'>)</font> <font color='#5555FF'>|</font><font color='#5555FF'>|</font> defined<font face='Lucida Console'>(</font>PNG_READ_ALPHA_MODE_SUPPORTED<font face='Lucida Console'>)</font>
<font color='#009900'>/* The output_gamma value is a screen gamma in libpng terminology: it expresses
 * how to decode the output values, not how they are encoded.  The values used
 * correspond to the normal numbers used to describe the overall gamma of a
 * computer display system; for example 2.2 for an sRGB conformant system.  The
 * values are scaled by 100000 in the _fixed version of the API (so 220000 for
 * sRGB.)
 *
 * The inverse of the value is always used to provide a default for the PNG file
 * encoding if it has no gAMA chunk and if png_set_gamma() has not been called
 * to override the PNG gamma information.
 *
 * When the ALPHA_OPTIMIZED mode is selected the output gamma is used to encode
 * opaque pixels however pixels with lower alpha values are not encoded,
 * regardless of the output gamma setting.
 *
 * When the standard Porter Duff handling is requested with mode 1 the output
 * encoding is set to be linear and the output_gamma value is only relevant
 * as a default for input data that has no gamma information.  The linear output
 * encoding will be overridden if png_set_gamma() is called - the results may be
 * highly unexpected!
 *
 * The following numbers are derived from the sRGB standard and the research
 * behind it.  sRGB is defined to be approximated by a PNG gAMA chunk value of
 * 0.45455 (1/2.2) for PNG.  The value implicitly includes any viewing
 * correction required to take account of any differences in the color
 * environment of the original scene and the intended display environment; the
 * value expresses how to *decode* the image for display, not how the original
 * data was *encoded*.
 *
 * sRGB provides a peg for the PNG standard by defining a viewing environment.
 * sRGB itself, and earlier TV standards, actually use a more complex transform
 * (a linear portion then a gamma 2.4 power law) than PNG can express.  (PNG is
 * limited to simple power laws.)  By saying that an image for direct display on
 * an sRGB conformant system should be stored with a gAMA chunk value of 45455
 * (11.3.3.2 and 11.3.3.5 of the ISO PNG specification) the PNG specification
 * makes it possible to derive values for other display systems and
 * environments.
 *
 * The Mac value is deduced from the sRGB based on an assumption that the actual
 * extra viewing correction used in early Mac display systems was implemented as
 * a power 1.45 lookup table.
 *
 * Any system where a programmable lookup table is used or where the behavior of
 * the final display device characteristics can be changed requires system
 * specific code to obtain the current characteristic.  However this can be
 * difficult and most PNG gamma correction only requires an approximate value.
 *
 * By default, if png_set_alpha_mode() is not called, libpng assumes that all
 * values are unencoded, linear, values and that the output device also has a
 * linear characteristic.  This is only very rarely correct - it is invariably
 * better to call png_set_alpha_mode() with PNG_DEFAULT_sRGB than rely on the
 * default if you don't know what the right answer is!
 *
 * The special value PNG_GAMMA_MAC_18 indicates an older Mac system (pre Mac OS
 * 10.6) which used a correction table to implement a somewhat lower gamma on an
 * otherwise sRGB system.
 *
 * Both these values are reserved (not simple gamma values) in order to allow
 * more precise correction internally in the future.
 *
 * NOTE: the following values can be passed to either the fixed or floating
 * point APIs, but the floating point API will also accept floating point
 * values.
 */</font>
<font color='#0000FF'>#define</font> PNG_DEFAULT_sRGB <font color='#5555FF'>-</font><font color='#979000'>1</font>       <font color='#009900'>/* sRGB gamma and color space */</font>
<font color='#0000FF'>#define</font> PNG_GAMMA_MAC_18 <font color='#5555FF'>-</font><font color='#979000'>2</font>       <font color='#009900'>/* Old Mac '1.8' gamma and color space */</font>
<font color='#0000FF'>#define</font> PNG_GAMMA_sRGB   <font color='#979000'>220000</font>   <font color='#009900'>/* Television standards--matches sRGB gamma */</font>
<font color='#0000FF'>#define</font> PNG_GAMMA_LINEAR PNG_FP_1 <font color='#009900'>/* Linear */</font>
<font color='#0000FF'>#endif</font>

<font color='#009900'>/* The following are examples of calls to png_set_alpha_mode to achieve the
 * required overall gamma correction and, where necessary, alpha
 * premultiplication.
 *
 * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_DEFAULT_sRGB);
 *    This is the default libpng handling of the alpha channel - it is not
 *    pre-multiplied into the color components.  In addition the call states
 *    that the output is for a sRGB system and causes all PNG files without gAMA
 *    chunks to be assumed to be encoded using sRGB.
 *
 * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_GAMMA_MAC);
 *    In this case the output is assumed to be something like an sRGB conformant
 *    display preceeded by a power-law lookup table of power 1.45.  This is how
 *    early Mac systems behaved.
 *
 * png_set_alpha_mode(pp, PNG_ALPHA_STANDARD, PNG_GAMMA_LINEAR);
 *    This is the classic Jim Blinn approach and will work in academic
 *    environments where everything is done by the book.  It has the shortcoming
 *    of assuming that input PNG data with no gamma information is linear - this
 *    is unlikely to be correct unless the PNG files where generated locally.
 *    Most of the time the output precision will be so low as to show
 *    significant banding in dark areas of the image.
 *
 * png_set_expand_16(pp);
 * png_set_alpha_mode(pp, PNG_ALPHA_STANDARD, PNG_DEFAULT_sRGB);
 *    This is a somewhat more realistic Jim Blinn inspired approach.  PNG files
 *    are assumed to have the sRGB encoding if not marked with a gamma value and
 *    the output is always 16 bits per component.  This permits accurate scaling
 *    and processing of the data.  If you know that your input PNG files were
 *    generated locally you might need to replace PNG_DEFAULT_sRGB with the
 *    correct value for your system.
 *
 * png_set_alpha_mode(pp, PNG_ALPHA_OPTIMIZED, PNG_DEFAULT_sRGB);
 *    If you just need to composite the PNG image onto an existing background
 *    and if you control the code that does this you can use the optimization
 *    setting.  In this case you just copy completely opaque pixels to the
 *    output.  For pixels that are not completely transparent (you just skip
 *    those) you do the composition math using png_composite or png_composite_16
 *    below then encode the resultant 8-bit or 16-bit values to match the output
 *    encoding.
 *
 * Other cases
 *    If neither the PNG nor the standard linear encoding work for you because
 *    of the software or hardware you use then you have a big problem.  The PNG
 *    case will probably result in halos around the image.  The linear encoding
 *    will probably result in a washed out, too bright, image (it's actually too
 *    contrasty.)  Try the ALPHA_OPTIMIZED mode above - this will probably
 *    substantially reduce the halos.  Alternatively try:
 *
 * png_set_alpha_mode(pp, PNG_ALPHA_BROKEN, PNG_DEFAULT_sRGB);
 *    This option will also reduce the halos, but there will be slight dark
 *    halos round the opaque parts of the image where the background is light.
 *    In the OPTIMIZED mode the halos will be light halos where the background
 *    is dark.  Take your pick - the halos are unavoidable unless you can get
 *    your hardware/software fixed!  (The OPTIMIZED approach is slightly
 *    faster.)
 *
 * When the default gamma of PNG files doesn't match the output gamma.
 *    If you have PNG files with no gamma information png_set_alpha_mode allows
 *    you to provide a default gamma, but it also sets the ouput gamma to the
 *    matching value.  If you know your PNG files have a gamma that doesn't
 *    match the output you can take advantage of the fact that
 *    png_set_alpha_mode always sets the output gamma but only sets the PNG
 *    default if it is not already set:
 *
 * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_DEFAULT_sRGB);
 * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_GAMMA_MAC);
 *    The first call sets both the default and the output gamma values, the
 *    second call overrides the output gamma without changing the default.  This
 *    is easier than achieving the same effect with png_set_gamma.  You must use
 *    PNG_ALPHA_PNG for the first call - internal checking in png_set_alpha will
 *    fire if more than one call to png_set_alpha_mode and png_set_background is
 *    made in the same read operation, however multiple calls with PNG_ALPHA_PNG
 *    are ignored.
 */</font>

<font color='#0000FF'>#ifdef</font> PNG_READ_STRIP_ALPHA_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>36</font>, <font color='#0000FF'><u>void</u></font>, png_set_strip_alpha, <font face='Lucida Console'>(</font>png_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#if</font> defined<font face='Lucida Console'>(</font>PNG_READ_SWAP_ALPHA_SUPPORTED<font face='Lucida Console'>)</font> <font color='#5555FF'>|</font><font color='#5555FF'>|</font> \
    <b><a name='defined'></a>defined</b><font face='Lucida Console'>(</font>PNG_WRITE_SWAP_ALPHA_SUPPORTED<font face='Lucida Console'>)</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>37</font>, <font color='#0000FF'><u>void</u></font>, png_set_swap_alpha, <font face='Lucida Console'>(</font>png_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#if</font> defined<font face='Lucida Console'>(</font>PNG_READ_INVERT_ALPHA_SUPPORTED<font face='Lucida Console'>)</font> <font color='#5555FF'>|</font><font color='#5555FF'>|</font> \
    <b><a name='defined'></a>defined</b><font face='Lucida Console'>(</font>PNG_WRITE_INVERT_ALPHA_SUPPORTED<font face='Lucida Console'>)</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>38</font>, <font color='#0000FF'><u>void</u></font>, png_set_invert_alpha, <font face='Lucida Console'>(</font>png_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#if</font> defined<font face='Lucida Console'>(</font>PNG_READ_FILLER_SUPPORTED<font face='Lucida Console'>)</font> <font color='#5555FF'>|</font><font color='#5555FF'>|</font> defined<font face='Lucida Console'>(</font>PNG_WRITE_FILLER_SUPPORTED<font face='Lucida Console'>)</font>
<font color='#009900'>/* Add a filler byte to 8-bit Gray or 24-bit RGB images. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>39</font>, <font color='#0000FF'><u>void</u></font>, png_set_filler, <font face='Lucida Console'>(</font>png_structrp png_ptr, png_uint_32 filler,
    <font color='#0000FF'><u>int</u></font> flags<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#009900'>/* The values of the PNG_FILLER_ defines should NOT be changed */</font>
#  define PNG_FILLER_BEFORE <font color='#979000'>0</font>
#  define PNG_FILLER_AFTER <font color='#979000'>1</font>
<font color='#009900'>/* Add an alpha byte to 8-bit Gray or 24-bit RGB images. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>40</font>, <font color='#0000FF'><u>void</u></font>, png_set_add_alpha, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    png_uint_32 filler, <font color='#0000FF'><u>int</u></font> flags<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font> <font color='#009900'>/* PNG_READ_FILLER_SUPPORTED || PNG_WRITE_FILLER_SUPPORTED */</font>

<font color='#0000FF'>#if</font> defined<font face='Lucida Console'>(</font>PNG_READ_SWAP_SUPPORTED<font face='Lucida Console'>)</font> <font color='#5555FF'>|</font><font color='#5555FF'>|</font> defined<font face='Lucida Console'>(</font>PNG_WRITE_SWAP_SUPPORTED<font face='Lucida Console'>)</font>
<font color='#009900'>/* Swap bytes in 16-bit depth files. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>41</font>, <font color='#0000FF'><u>void</u></font>, png_set_swap, <font face='Lucida Console'>(</font>png_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#if</font> defined<font face='Lucida Console'>(</font>PNG_READ_PACK_SUPPORTED<font face='Lucida Console'>)</font> <font color='#5555FF'>|</font><font color='#5555FF'>|</font> defined<font face='Lucida Console'>(</font>PNG_WRITE_PACK_SUPPORTED<font face='Lucida Console'>)</font>
<font color='#009900'>/* Use 1 byte per pixel in 1, 2, or 4-bit depth files. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>42</font>, <font color='#0000FF'><u>void</u></font>, png_set_packing, <font face='Lucida Console'>(</font>png_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#if</font> defined<font face='Lucida Console'>(</font>PNG_READ_PACKSWAP_SUPPORTED<font face='Lucida Console'>)</font> <font color='#5555FF'>|</font><font color='#5555FF'>|</font> \
    <b><a name='defined'></a>defined</b><font face='Lucida Console'>(</font>PNG_WRITE_PACKSWAP_SUPPORTED<font face='Lucida Console'>)</font>
<font color='#009900'>/* Swap packing order of pixels in bytes. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>43</font>, <font color='#0000FF'><u>void</u></font>, png_set_packswap, <font face='Lucida Console'>(</font>png_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#if</font> defined<font face='Lucida Console'>(</font>PNG_READ_SHIFT_SUPPORTED<font face='Lucida Console'>)</font> <font color='#5555FF'>|</font><font color='#5555FF'>|</font> defined<font face='Lucida Console'>(</font>PNG_WRITE_SHIFT_SUPPORTED<font face='Lucida Console'>)</font>
<font color='#009900'>/* Converts files to legal bit depths. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>44</font>, <font color='#0000FF'><u>void</u></font>, png_set_shift, <font face='Lucida Console'>(</font>png_structrp png_ptr, png_const_color_8p
    true_bits<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#if</font> defined<font face='Lucida Console'>(</font>PNG_READ_INTERLACING_SUPPORTED<font face='Lucida Console'>)</font> <font color='#5555FF'>|</font><font color='#5555FF'>|</font> \
    <b><a name='defined'></a>defined</b><font face='Lucida Console'>(</font>PNG_WRITE_INTERLACING_SUPPORTED<font face='Lucida Console'>)</font>
<font color='#009900'>/* Have the code handle the interlacing.  Returns the number of passes.
 * MUST be called before png_read_update_info or png_start_read_image,
 * otherwise it will not have the desired effect.  Note that it is still
 * necessary to call png_read_row or png_read_rows png_get_image_height
 * times for each pass.
*/</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>45</font>, <font color='#0000FF'><u>int</u></font>, png_set_interlace_handling, <font face='Lucida Console'>(</font>png_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#if</font> defined<font face='Lucida Console'>(</font>PNG_READ_INVERT_SUPPORTED<font face='Lucida Console'>)</font> <font color='#5555FF'>|</font><font color='#5555FF'>|</font> defined<font face='Lucida Console'>(</font>PNG_WRITE_INVERT_SUPPORTED<font face='Lucida Console'>)</font>
<font color='#009900'>/* Invert monochrome files */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>46</font>, <font color='#0000FF'><u>void</u></font>, png_set_invert_mono, <font face='Lucida Console'>(</font>png_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_READ_BACKGROUND_SUPPORTED
<font color='#009900'>/* Handle alpha and tRNS by replacing with a background color.  Prior to
 * libpng-1.5.4 this API must not be called before the PNG file header has been
 * read.  Doing so will result in unexpected behavior and possible warnings or
 * errors if the PNG file contains a bKGD chunk.
 */</font>
<b><a name='PNG_FP_EXPORT'></a>PNG_FP_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>47</font>, <font color='#0000FF'><u>void</u></font>, png_set_background, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    png_const_color_16p background_color, <font color='#0000FF'><u>int</u></font> background_gamma_code,
    <font color='#0000FF'><u>int</u></font> need_expand, <font color='#0000FF'><u>double</u></font> background_gamma<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<b><a name='PNG_FIXED_EXPORT'></a>PNG_FIXED_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>215</font>, <font color='#0000FF'><u>void</u></font>, png_set_background_fixed, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    png_const_color_16p background_color, <font color='#0000FF'><u>int</u></font> background_gamma_code,
    <font color='#0000FF'><u>int</u></font> need_expand, png_fixed_point background_gamma<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<font color='#0000FF'>#endif</font>
<font color='#0000FF'>#ifdef</font> PNG_READ_BACKGROUND_SUPPORTED
#  define PNG_BACKGROUND_GAMMA_UNKNOWN <font color='#979000'>0</font>
#  define PNG_BACKGROUND_GAMMA_SCREEN  <font color='#979000'>1</font>
#  define PNG_BACKGROUND_GAMMA_FILE    <font color='#979000'>2</font>
#  define PNG_BACKGROUND_GAMMA_UNIQUE  <font color='#979000'>3</font>
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_READ_SCALE_16_TO_8_SUPPORTED
<font color='#009900'>/* Scale a 16-bit depth file down to 8-bit, accurately. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>229</font>, <font color='#0000FF'><u>void</u></font>, png_set_scale_16, <font face='Lucida Console'>(</font>png_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_READ_STRIP_16_TO_8_SUPPORTED
<font color='#0000FF'>#define</font> PNG_READ_16_TO_8 SUPPORTED <font color='#009900'>/* Name prior to 1.5.4 */</font>
<font color='#009900'>/* Strip the second byte of information from a 16-bit depth file. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>48</font>, <font color='#0000FF'><u>void</u></font>, png_set_strip_16, <font face='Lucida Console'>(</font>png_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_READ_QUANTIZE_SUPPORTED
<font color='#009900'>/* Turn on quantizing, and reduce the palette to the number of colors
 * available.
 */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>49</font>, <font color='#0000FF'><u>void</u></font>, png_set_quantize, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    png_colorp palette, <font color='#0000FF'><u>int</u></font> num_palette, <font color='#0000FF'><u>int</u></font> maximum_colors,
    png_const_uint_16p histogram, <font color='#0000FF'><u>int</u></font> full_quantize<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_READ_GAMMA_SUPPORTED
<font color='#009900'>/* The threshold on gamma processing is configurable but hard-wired into the
 * library.  The following is the floating point variant.
 */</font>
<font color='#0000FF'>#define</font> PNG_GAMMA_THRESHOLD <font face='Lucida Console'>(</font>PNG_GAMMA_THRESHOLD_FIXED<font color='#5555FF'>*</font>.<font color='#979000'>00001</font><font face='Lucida Console'>)</font>

<font color='#009900'>/* Handle gamma correction. Screen_gamma=(display_exponent).
 * NOTE: this API simply sets the screen and file gamma values. It will
 * therefore override the value for gamma in a PNG file if it is called after
 * the file header has been read - use with care  - call before reading the PNG
 * file for best results!
 *
 * These routines accept the same gamma values as png_set_alpha_mode (described
 * above).  The PNG_GAMMA_ defines and PNG_DEFAULT_sRGB can be passed to either
 * API (floating point or fixed.)  Notice, however, that the 'file_gamma' value
 * is the inverse of a 'screen gamma' value.
 */</font>
<b><a name='PNG_FP_EXPORT'></a>PNG_FP_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>50</font>, <font color='#0000FF'><u>void</u></font>, png_set_gamma, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    <font color='#0000FF'><u>double</u></font> screen_gamma, <font color='#0000FF'><u>double</u></font> override_file_gamma<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<b><a name='PNG_FIXED_EXPORT'></a>PNG_FIXED_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>208</font>, <font color='#0000FF'><u>void</u></font>, png_set_gamma_fixed, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    png_fixed_point screen_gamma, png_fixed_point override_file_gamma<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_WRITE_FLUSH_SUPPORTED
<font color='#009900'>/* Set how many lines between output flushes - 0 for no flushing */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>51</font>, <font color='#0000FF'><u>void</u></font>, png_set_flush, <font face='Lucida Console'>(</font>png_structrp png_ptr, <font color='#0000FF'><u>int</u></font> nrows<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#009900'>/* Flush the current PNG output buffer */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>52</font>, <font color='#0000FF'><u>void</u></font>, png_write_flush, <font face='Lucida Console'>(</font>png_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#009900'>/* Optional update palette with requested transformations */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>53</font>, <font color='#0000FF'><u>void</u></font>, png_start_read_image, <font face='Lucida Console'>(</font>png_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Optional call to update the users info structure */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>54</font>, <font color='#0000FF'><u>void</u></font>, png_read_update_info, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    png_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#0000FF'>#ifdef</font> PNG_SEQUENTIAL_READ_SUPPORTED
<font color='#009900'>/* Read one or more rows of image data. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>55</font>, <font color='#0000FF'><u>void</u></font>, png_read_rows, <font face='Lucida Console'>(</font>png_structrp png_ptr, png_bytepp row,
    png_bytepp display_row, png_uint_32 num_rows<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_SEQUENTIAL_READ_SUPPORTED
<font color='#009900'>/* Read a row of data. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>56</font>, <font color='#0000FF'><u>void</u></font>, png_read_row, <font face='Lucida Console'>(</font>png_structrp png_ptr, png_bytep row,
    png_bytep display_row<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_SEQUENTIAL_READ_SUPPORTED
<font color='#009900'>/* Read the whole image into memory at once. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>57</font>, <font color='#0000FF'><u>void</u></font>, png_read_image, <font face='Lucida Console'>(</font>png_structrp png_ptr, png_bytepp image<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#009900'>/* Write a row of image data */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>58</font>, <font color='#0000FF'><u>void</u></font>, png_write_row, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    png_const_bytep row<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Write a few rows of image data: (*row) is not written; however, the type
 * is declared as writeable to maintain compatibility with previous versions
 * of libpng and to allow the 'display_row' array from read_rows to be passed
 * unchanged to write_rows.
 */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>59</font>, <font color='#0000FF'><u>void</u></font>, png_write_rows, <font face='Lucida Console'>(</font>png_structrp png_ptr, png_bytepp row,
    png_uint_32 num_rows<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Write the image data */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>60</font>, <font color='#0000FF'><u>void</u></font>, png_write_image, <font face='Lucida Console'>(</font>png_structrp png_ptr, png_bytepp image<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Write the end of the PNG file. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>61</font>, <font color='#0000FF'><u>void</u></font>, png_write_end, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    png_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#0000FF'>#ifdef</font> PNG_SEQUENTIAL_READ_SUPPORTED
<font color='#009900'>/* Read the end of the PNG file. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>62</font>, <font color='#0000FF'><u>void</u></font>, png_read_end, <font face='Lucida Console'>(</font>png_structrp png_ptr, png_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#009900'>/* Free any memory associated with the png_info_struct */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>63</font>, <font color='#0000FF'><u>void</u></font>, png_destroy_info_struct, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_infopp info_ptr_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Free any memory associated with the png_struct and the png_info_structs */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>64</font>, <font color='#0000FF'><u>void</u></font>, png_destroy_read_struct, <font face='Lucida Console'>(</font>png_structpp png_ptr_ptr,
    png_infopp info_ptr_ptr, png_infopp end_info_ptr_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Free any memory associated with the png_struct and the png_info_structs */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>65</font>, <font color='#0000FF'><u>void</u></font>, png_destroy_write_struct, <font face='Lucida Console'>(</font>png_structpp png_ptr_ptr,
    png_infopp info_ptr_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Set the libpng method of handling chunk CRC errors */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>66</font>, <font color='#0000FF'><u>void</u></font>, png_set_crc_action, <font face='Lucida Console'>(</font>png_structrp png_ptr, <font color='#0000FF'><u>int</u></font> crit_action,
    <font color='#0000FF'><u>int</u></font> ancil_action<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Values for png_set_crc_action() say how to handle CRC errors in
 * ancillary and critical chunks, and whether to use the data contained
 * therein.  Note that it is impossible to "discard" data in a critical
 * chunk.  For versions prior to 0.90, the action was always error/quit,
 * whereas in version 0.90 and later, the action for CRC errors in ancillary
 * chunks is warn/discard.  These values should NOT be changed.
 *
 *      value                       action:critical     action:ancillary
 */</font>
<font color='#0000FF'>#define</font> PNG_CRC_DEFAULT       <font color='#979000'>0</font>  <font color='#009900'>/* error/quit          warn/discard data */</font>
<font color='#0000FF'>#define</font> PNG_CRC_ERROR_QUIT    <font color='#979000'>1</font>  <font color='#009900'>/* error/quit          error/quit        */</font>
<font color='#0000FF'>#define</font> PNG_CRC_WARN_DISCARD  <font color='#979000'>2</font>  <font color='#009900'>/* (INVALID)           warn/discard data */</font>
<font color='#0000FF'>#define</font> PNG_CRC_WARN_USE      <font color='#979000'>3</font>  <font color='#009900'>/* warn/use data       warn/use data     */</font>
<font color='#0000FF'>#define</font> PNG_CRC_QUIET_USE     <font color='#979000'>4</font>  <font color='#009900'>/* quiet/use data      quiet/use data    */</font>
<font color='#0000FF'>#define</font> PNG_CRC_NO_CHANGE     <font color='#979000'>5</font>  <font color='#009900'>/* use current value   use current value */</font>

<font color='#009900'>/* These functions give the user control over the scan-line filtering in
 * libpng and the compression methods used by zlib.  These functions are
 * mainly useful for testing, as the defaults should work with most users.
 * Those users who are tight on memory or want faster performance at the
 * expense of compression can modify them.  See the compression library
 * header file (zlib.h) for an explination of the compression functions.
 */</font>

<font color='#009900'>/* Set the filtering method(s) used by libpng.  Currently, the only valid
 * value for "method" is 0.
 */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>67</font>, <font color='#0000FF'><u>void</u></font>, png_set_filter, <font face='Lucida Console'>(</font>png_structrp png_ptr, <font color='#0000FF'><u>int</u></font> method,
    <font color='#0000FF'><u>int</u></font> filters<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Flags for png_set_filter() to say which filters to use.  The flags
 * are chosen so that they don't conflict with real filter types
 * below, in case they are supplied instead of the #defined constants.
 * These values should NOT be changed.
 */</font>
<font color='#0000FF'>#define</font> PNG_NO_FILTERS     <font color='#979000'>0x00</font>
<font color='#0000FF'>#define</font> PNG_FILTER_NONE    <font color='#979000'>0x08</font>
<font color='#0000FF'>#define</font> PNG_FILTER_SUB     <font color='#979000'>0x10</font>
<font color='#0000FF'>#define</font> PNG_FILTER_UP      <font color='#979000'>0x20</font>
<font color='#0000FF'>#define</font> PNG_FILTER_AVG     <font color='#979000'>0x40</font>
<font color='#0000FF'>#define</font> PNG_FILTER_PAETH   <font color='#979000'>0x80</font>
<font color='#0000FF'>#define</font> PNG_ALL_FILTERS <font face='Lucida Console'>(</font>PNG_FILTER_NONE <font color='#5555FF'>|</font> PNG_FILTER_SUB <font color='#5555FF'>|</font> PNG_FILTER_UP <font color='#5555FF'>|</font> \
                         PNG_FILTER_AVG <font color='#5555FF'>|</font> PNG_FILTER_PAETH<font face='Lucida Console'>)</font>

<font color='#009900'>/* Filter values (not flags) - used in pngwrite.c, pngwutil.c for now.
 * These defines should NOT be changed.
 */</font>
<font color='#0000FF'>#define</font> PNG_FILTER_VALUE_NONE  <font color='#979000'>0</font>
<font color='#0000FF'>#define</font> PNG_FILTER_VALUE_SUB   <font color='#979000'>1</font>
<font color='#0000FF'>#define</font> PNG_FILTER_VALUE_UP    <font color='#979000'>2</font>
<font color='#0000FF'>#define</font> PNG_FILTER_VALUE_AVG   <font color='#979000'>3</font>
<font color='#0000FF'>#define</font> PNG_FILTER_VALUE_PAETH <font color='#979000'>4</font>
<font color='#0000FF'>#define</font> PNG_FILTER_VALUE_LAST  <font color='#979000'>5</font>

<font color='#0000FF'>#ifdef</font> PNG_WRITE_WEIGHTED_FILTER_SUPPORTED <font color='#009900'>/* EXPERIMENTAL */</font>
<font color='#009900'>/* The "heuristic_method" is given by one of the PNG_FILTER_HEURISTIC_
 * defines, either the default (minimum-sum-of-absolute-differences), or
 * the experimental method (weighted-minimum-sum-of-absolute-differences).
 *
 * Weights are factors &gt;= 1.0, indicating how important it is to keep the
 * filter type consistent between rows.  Larger numbers mean the current
 * filter is that many times as likely to be the same as the "num_weights"
 * previous filters.  This is cumulative for each previous row with a weight.
 * There needs to be "num_weights" values in "filter_weights", or it can be
 * NULL if the weights aren't being specified.  Weights have no influence on
 * the selection of the first row filter.  Well chosen weights can (in theory)
 * improve the compression for a given image.
 *
 * Costs are factors &gt;= 1.0 indicating the relative decoding costs of a
 * filter type.  Higher costs indicate more decoding expense, and are
 * therefore less likely to be selected over a filter with lower computational
 * costs.  There needs to be a value in "filter_costs" for each valid filter
 * type (given by PNG_FILTER_VALUE_LAST), or it can be NULL if you aren't
 * setting the costs.  Costs try to improve the speed of decompression without
 * unduly increasing the compressed image size.
 *
 * A negative weight or cost indicates the default value is to be used, and
 * values in the range [0.0, 1.0) indicate the value is to remain unchanged.
 * The default values for both weights and costs are currently 1.0, but may
 * change if good general weighting/cost heuristics can be found.  If both
 * the weights and costs are set to 1.0, this degenerates the WEIGHTED method
 * to the UNWEIGHTED method, but with added encoding time/computation.
 */</font>
<b><a name='PNG_FP_EXPORT'></a>PNG_FP_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>68</font>, <font color='#0000FF'><u>void</u></font>, png_set_filter_heuristics, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    <font color='#0000FF'><u>int</u></font> heuristic_method, <font color='#0000FF'><u>int</u></font> num_weights, png_const_doublep filter_weights,
    png_const_doublep filter_costs<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<b><a name='PNG_FIXED_EXPORT'></a>PNG_FIXED_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>209</font>, <font color='#0000FF'><u>void</u></font>, png_set_filter_heuristics_fixed,
    <font face='Lucida Console'>(</font>png_structrp png_ptr, <font color='#0000FF'><u>int</u></font> heuristic_method, <font color='#0000FF'><u>int</u></font> num_weights,
    png_const_fixed_point_p filter_weights,
    png_const_fixed_point_p filter_costs<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<font color='#0000FF'>#endif</font> <font color='#009900'>/*  PNG_WRITE_WEIGHTED_FILTER_SUPPORTED */</font>

<font color='#009900'>/* Heuristic used for row filter selection.  These defines should NOT be
 * changed.
 */</font>
<font color='#0000FF'>#define</font> PNG_FILTER_HEURISTIC_DEFAULT    <font color='#979000'>0</font>  <font color='#009900'>/* Currently "UNWEIGHTED" */</font>
<font color='#0000FF'>#define</font> PNG_FILTER_HEURISTIC_UNWEIGHTED <font color='#979000'>1</font>  <font color='#009900'>/* Used by libpng &lt; 0.95 */</font>
<font color='#0000FF'>#define</font> PNG_FILTER_HEURISTIC_WEIGHTED   <font color='#979000'>2</font>  <font color='#009900'>/* Experimental feature */</font>
<font color='#0000FF'>#define</font> PNG_FILTER_HEURISTIC_LAST       <font color='#979000'>3</font>  <font color='#009900'>/* Not a valid value */</font>

<font color='#0000FF'>#ifdef</font> PNG_WRITE_SUPPORTED
<font color='#009900'>/* Set the library compression level.  Currently, valid values range from
 * 0 - 9, corresponding directly to the zlib compression levels 0 - 9
 * (0 - no compression, 9 - "maximal" compression).  Note that tests have
 * shown that zlib compression levels 3-6 usually perform as well as level 9
 * for PNG images, and do considerably fewer caclulations.  In the future,
 * these values may not correspond directly to the zlib compression levels.
 */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>69</font>, <font color='#0000FF'><u>void</u></font>, png_set_compression_level, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    <font color='#0000FF'><u>int</u></font> level<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>70</font>, <font color='#0000FF'><u>void</u></font>, png_set_compression_mem_level, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    <font color='#0000FF'><u>int</u></font> mem_level<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>71</font>, <font color='#0000FF'><u>void</u></font>, png_set_compression_strategy, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    <font color='#0000FF'><u>int</u></font> strategy<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* If PNG_WRITE_OPTIMIZE_CMF_SUPPORTED is defined, libpng will use a
 * smaller value of window_bits if it can do so safely.
 */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>72</font>, <font color='#0000FF'><u>void</u></font>, png_set_compression_window_bits, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    <font color='#0000FF'><u>int</u></font> window_bits<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>73</font>, <font color='#0000FF'><u>void</u></font>, png_set_compression_method, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    <font color='#0000FF'><u>int</u></font> method<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED
<font color='#009900'>/* Also set zlib parameters for compressing non-IDAT chunks */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>222</font>, <font color='#0000FF'><u>void</u></font>, png_set_text_compression_level, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    <font color='#0000FF'><u>int</u></font> level<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>223</font>, <font color='#0000FF'><u>void</u></font>, png_set_text_compression_mem_level, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    <font color='#0000FF'><u>int</u></font> mem_level<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>224</font>, <font color='#0000FF'><u>void</u></font>, png_set_text_compression_strategy, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    <font color='#0000FF'><u>int</u></font> strategy<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* If PNG_WRITE_OPTIMIZE_CMF_SUPPORTED is defined, libpng will use a
 * smaller value of window_bits if it can do so safely.
 */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>225</font>, <font color='#0000FF'><u>void</u></font>, png_set_text_compression_window_bits,
    <font face='Lucida Console'>(</font>png_structrp png_ptr, <font color='#0000FF'><u>int</u></font> window_bits<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>226</font>, <font color='#0000FF'><u>void</u></font>, png_set_text_compression_method, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    <font color='#0000FF'><u>int</u></font> method<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font> <font color='#009900'>/* PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED */</font>

<font color='#009900'>/* These next functions are called for input/output, memory, and error
 * handling.  They are in the file pngrio.c, pngwio.c, and pngerror.c,
 * and call standard C I/O routines such as fread(), fwrite(), and
 * fprintf().  These functions can be made to use other I/O routines
 * at run time for those applications that need to handle I/O in a
 * different manner by calling png_set_???_fn().  See libpng-manual.txt for
 * more information.
 */</font>

<font color='#0000FF'>#ifdef</font> PNG_STDIO_SUPPORTED
<font color='#009900'>/* Initialize the input/output for the PNG file to the default functions. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>74</font>, <font color='#0000FF'><u>void</u></font>, png_init_io, <font face='Lucida Console'>(</font>png_structrp png_ptr, png_FILE_p fp<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#009900'>/* Replace the (error and abort), and warning functions with user
 * supplied functions.  If no messages are to be printed you must still
 * write and use replacement functions. The replacement error_fn should
 * still do a longjmp to the last setjmp location if you are using this
 * method of error handling.  If error_fn or warning_fn is NULL, the
 * default function will be used.
 */</font>

<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>75</font>, <font color='#0000FF'><u>void</u></font>, png_set_error_fn, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    png_voidp error_ptr, png_error_ptr error_fn, png_error_ptr warning_fn<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Return the user pointer associated with the error functions */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>76</font>, png_voidp, png_get_error_ptr, <font face='Lucida Console'>(</font>png_const_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Replace the default data output functions with a user supplied one(s).
 * If buffered output is not used, then output_flush_fn can be set to NULL.
 * If PNG_WRITE_FLUSH_SUPPORTED is not defined at libpng compile time
 * output_flush_fn will be ignored (and thus can be NULL).
 * It is probably a mistake to use NULL for output_flush_fn if
 * write_data_fn is not also NULL unless you have built libpng with
 * PNG_WRITE_FLUSH_SUPPORTED undefined, because in this case libpng's
 * default flush function, which uses the standard *FILE structure, will
 * be used.
 */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>77</font>, <font color='#0000FF'><u>void</u></font>, png_set_write_fn, <font face='Lucida Console'>(</font>png_structrp png_ptr, png_voidp io_ptr,
    png_rw_ptr write_data_fn, png_flush_ptr output_flush_fn<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Replace the default data input function with a user supplied one. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>78</font>, <font color='#0000FF'><u>void</u></font>, png_set_read_fn, <font face='Lucida Console'>(</font>png_structrp png_ptr, png_voidp io_ptr,
    png_rw_ptr read_data_fn<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Return the user pointer associated with the I/O functions */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>79</font>, png_voidp, png_get_io_ptr, <font face='Lucida Console'>(</font>png_const_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>80</font>, <font color='#0000FF'><u>void</u></font>, png_set_read_status_fn, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    png_read_status_ptr read_row_fn<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>81</font>, <font color='#0000FF'><u>void</u></font>, png_set_write_status_fn, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    png_write_status_ptr write_row_fn<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#0000FF'>#ifdef</font> PNG_USER_MEM_SUPPORTED
<font color='#009900'>/* Replace the default memory allocation functions with user supplied one(s). */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>82</font>, <font color='#0000FF'><u>void</u></font>, png_set_mem_fn, <font face='Lucida Console'>(</font>png_structrp png_ptr, png_voidp mem_ptr,
    png_malloc_ptr malloc_fn, png_free_ptr free_fn<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#009900'>/* Return the user pointer associated with the memory functions */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>83</font>, png_voidp, png_get_mem_ptr, <font face='Lucida Console'>(</font>png_const_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_READ_USER_TRANSFORM_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>84</font>, <font color='#0000FF'><u>void</u></font>, png_set_read_user_transform_fn, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    png_user_transform_ptr read_user_transform_fn<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_WRITE_USER_TRANSFORM_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>85</font>, <font color='#0000FF'><u>void</u></font>, png_set_write_user_transform_fn, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    png_user_transform_ptr write_user_transform_fn<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_USER_TRANSFORM_PTR_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>86</font>, <font color='#0000FF'><u>void</u></font>, png_set_user_transform_info, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    png_voidp user_transform_ptr, <font color='#0000FF'><u>int</u></font> user_transform_depth,
    <font color='#0000FF'><u>int</u></font> user_transform_channels<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#009900'>/* Return the user pointer associated with the user transform functions */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>87</font>, png_voidp, png_get_user_transform_ptr,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_USER_TRANSFORM_INFO_SUPPORTED
<font color='#009900'>/* Return information about the row currently being processed.  Note that these
 * APIs do not fail but will return unexpected results if called outside a user
 * transform callback.  Also note that when transforming an interlaced image the
 * row number is the row number within the sub-image of the interlace pass, so
 * the value will increase to the height of the sub-image (not the full image)
 * then reset to 0 for the next pass.
 *
 * Use PNG_ROW_FROM_PASS_ROW(row, pass) and PNG_COL_FROM_PASS_COL(col, pass) to
 * find the output pixel (x,y) given an interlaced sub-image pixel
 * (row,col,pass).  (See below for these macros.)
 */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>217</font>, png_uint_32, png_get_current_row_number, <font face='Lucida Console'>(</font>png_const_structrp<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>218</font>, png_byte, png_get_current_pass_number, <font face='Lucida Console'>(</font>png_const_structrp<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_READ_USER_CHUNKS_SUPPORTED
<font color='#009900'>/* This callback is called only for *unknown* chunks.  If
 * PNG_HANDLE_AS_UNKNOWN_SUPPORTED is set then it is possible to set known
 * chunks to be treated as unknown, however in this case the callback must do
 * any processing required by the chunk (e.g. by calling the appropriate
 * png_set_ APIs.)
 *
 * There is no write support - on write, by default, all the chunks in the
 * 'unknown' list are written in the specified position.
 *
 * The integer return from the callback function is interpreted thus:
 *
 * negative: An error occured, png_chunk_error will be called.
 *     zero: The chunk was not handled, the chunk will be saved. A critical
 *           chunk will cause an error at this point unless it is to be saved.
 * positive: The chunk was handled, libpng will ignore/discard it.
 *
 * See "INTERACTION WTIH USER CHUNK CALLBACKS" below for important notes about
 * how this behavior will change in libpng 1.7
 */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>88</font>, <font color='#0000FF'><u>void</u></font>, png_set_read_user_chunk_fn, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    png_voidp user_chunk_ptr, png_user_chunk_ptr read_user_chunk_fn<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_USER_CHUNKS_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>89</font>, png_voidp, png_get_user_chunk_ptr, <font face='Lucida Console'>(</font>png_const_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_PROGRESSIVE_READ_SUPPORTED
<font color='#009900'>/* Sets the function callbacks for the push reader, and a pointer to a
 * user-defined structure available to the callback functions.
 */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>90</font>, <font color='#0000FF'><u>void</u></font>, png_set_progressive_read_fn, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    png_voidp progressive_ptr, png_progressive_info_ptr info_fn,
    png_progressive_row_ptr row_fn, png_progressive_end_ptr end_fn<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Returns the user pointer associated with the push read functions */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>91</font>, png_voidp, png_get_progressive_ptr,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Function to be called when data becomes available */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>92</font>, <font color='#0000FF'><u>void</u></font>, png_process_data, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    png_inforp info_ptr, png_bytep buffer, png_size_t buffer_size<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* A function which may be called *only* within png_process_data to stop the
 * processing of any more data.  The function returns the number of bytes
 * remaining, excluding any that libpng has cached internally.  A subsequent
 * call to png_process_data must supply these bytes again.  If the argument
 * 'save' is set to true the routine will first save all the pending data and
 * will always return 0.
 */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>219</font>, png_size_t, png_process_data_pause, <font face='Lucida Console'>(</font>png_structrp, <font color='#0000FF'><u>int</u></font> save<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* A function which may be called *only* outside (after) a call to
 * png_process_data.  It returns the number of bytes of data to skip in the
 * input.  Normally it will return 0, but if it returns a non-zero value the
 * application must skip than number of bytes of input data and pass the
 * following data to the next call to png_process_data.
 */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>220</font>, png_uint_32, png_process_data_skip, <font face='Lucida Console'>(</font>png_structrp<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#0000FF'>#ifdef</font> PNG_READ_INTERLACING_SUPPORTED
<font color='#009900'>/* Function that combines rows.  'new_row' is a flag that should come from
 * the callback and be non-NULL if anything needs to be done; the library
 * stores its own version of the new data internally and ignores the passed
 * in value.
 */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>93</font>, <font color='#0000FF'><u>void</u></font>, png_progressive_combine_row, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_bytep old_row, png_const_bytep new_row<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font> <font color='#009900'>/* PNG_READ_INTERLACING_SUPPORTED */</font>
<font color='#0000FF'>#endif</font> <font color='#009900'>/* PNG_PROGRESSIVE_READ_SUPPORTED */</font>

<b><a name='PNG_EXPORTA'></a>PNG_EXPORTA</b><font face='Lucida Console'>(</font><font color='#979000'>94</font>, png_voidp, png_malloc, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_alloc_size_t size<font face='Lucida Console'>)</font>, PNG_ALLOCATED<font face='Lucida Console'>)</font>;
<font color='#009900'>/* Added at libpng version 1.4.0 */</font>
<b><a name='PNG_EXPORTA'></a>PNG_EXPORTA</b><font face='Lucida Console'>(</font><font color='#979000'>95</font>, png_voidp, png_calloc, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_alloc_size_t size<font face='Lucida Console'>)</font>, PNG_ALLOCATED<font face='Lucida Console'>)</font>;

<font color='#009900'>/* Added at libpng version 1.2.4 */</font>
<b><a name='PNG_EXPORTA'></a>PNG_EXPORTA</b><font face='Lucida Console'>(</font><font color='#979000'>96</font>, png_voidp, png_malloc_warn, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_alloc_size_t size<font face='Lucida Console'>)</font>, PNG_ALLOCATED<font face='Lucida Console'>)</font>;

<font color='#009900'>/* Frees a pointer allocated by png_malloc() */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>97</font>, <font color='#0000FF'><u>void</u></font>, png_free, <font face='Lucida Console'>(</font>png_const_structrp png_ptr, png_voidp ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Free data that was allocated internally */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>98</font>, <font color='#0000FF'><u>void</u></font>, png_free_data, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 free_me, <font color='#0000FF'><u>int</u></font> num<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Reassign responsibility for freeing existing data, whether allocated
 * by libpng or by the application; this works on the png_info structure passed
 * in, it does not change the state for other png_info structures.
 *
 * It is unlikely that this function works correctly as of 1.6.0 and using it
 * may result either in memory leaks or double free of allocated data.
 */</font>
<b><a name='PNG_EXPORTA'></a>PNG_EXPORTA</b><font face='Lucida Console'>(</font><font color='#979000'>99</font>, <font color='#0000FF'><u>void</u></font>, png_data_freer, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, <font color='#0000FF'><u>int</u></font> freer, png_uint_32 mask<font face='Lucida Console'>)</font>, PNG_DEPRECATED<font face='Lucida Console'>)</font>;

<font color='#009900'>/* Assignments for png_data_freer */</font>
<font color='#0000FF'>#define</font> PNG_DESTROY_WILL_FREE_DATA <font color='#979000'>1</font>
<font color='#0000FF'>#define</font> PNG_SET_WILL_FREE_DATA <font color='#979000'>1</font>
<font color='#0000FF'>#define</font> PNG_USER_WILL_FREE_DATA <font color='#979000'>2</font>
<font color='#009900'>/* Flags for png_ptr-&gt;free_me and info_ptr-&gt;free_me */</font>
<font color='#0000FF'>#define</font> PNG_FREE_HIST <font color='#979000'>0x0008</font>
<font color='#0000FF'>#define</font> PNG_FREE_ICCP <font color='#979000'>0x0010</font>
<font color='#0000FF'>#define</font> PNG_FREE_SPLT <font color='#979000'>0x0020</font>
<font color='#0000FF'>#define</font> PNG_FREE_ROWS <font color='#979000'>0x0040</font>
<font color='#0000FF'>#define</font> PNG_FREE_PCAL <font color='#979000'>0x0080</font>
<font color='#0000FF'>#define</font> PNG_FREE_SCAL <font color='#979000'>0x0100</font>
<font color='#0000FF'>#ifdef</font> PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED
#  define PNG_FREE_UNKN <font color='#979000'>0x0200</font>
<font color='#0000FF'>#endif</font>
<font color='#009900'>/*      PNG_FREE_LIST 0x0400    removed in 1.6.0 because it is ignored */</font>
<font color='#0000FF'>#define</font> PNG_FREE_PLTE <font color='#979000'>0x1000</font>
<font color='#0000FF'>#define</font> PNG_FREE_TRNS <font color='#979000'>0x2000</font>
<font color='#0000FF'>#define</font> PNG_FREE_TEXT <font color='#979000'>0x4000</font>
<font color='#0000FF'>#define</font> PNG_FREE_ALL  <font color='#979000'>0x7fff</font>
<font color='#0000FF'>#define</font> PNG_FREE_MUL  <font color='#979000'>0x4220</font> <font color='#009900'>/* PNG_FREE_SPLT|PNG_FREE_TEXT|PNG_FREE_UNKN */</font>

<font color='#0000FF'>#ifdef</font> PNG_USER_MEM_SUPPORTED
<b><a name='PNG_EXPORTA'></a>PNG_EXPORTA</b><font face='Lucida Console'>(</font><font color='#979000'>100</font>, png_voidp, png_malloc_default, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_alloc_size_t size<font face='Lucida Console'>)</font>, PNG_ALLOCATED PNG_DEPRECATED<font face='Lucida Console'>)</font>;
<b><a name='PNG_EXPORTA'></a>PNG_EXPORTA</b><font face='Lucida Console'>(</font><font color='#979000'>101</font>, <font color='#0000FF'><u>void</u></font>, png_free_default, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_voidp ptr<font face='Lucida Console'>)</font>, PNG_DEPRECATED<font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_ERROR_TEXT_SUPPORTED
<font color='#009900'>/* Fatal error in PNG image of libpng - can't continue */</font>
<b><a name='PNG_EXPORTA'></a>PNG_EXPORTA</b><font face='Lucida Console'>(</font><font color='#979000'>102</font>, <font color='#0000FF'><u>void</u></font>, png_error, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_const_charp error_message<font face='Lucida Console'>)</font>, PNG_NORETURN<font face='Lucida Console'>)</font>;

<font color='#009900'>/* The same, but the chunk name is prepended to the error string. */</font>
<b><a name='PNG_EXPORTA'></a>PNG_EXPORTA</b><font face='Lucida Console'>(</font><font color='#979000'>103</font>, <font color='#0000FF'><u>void</u></font>, png_chunk_error, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_const_charp error_message<font face='Lucida Console'>)</font>, PNG_NORETURN<font face='Lucida Console'>)</font>;

<font color='#0000FF'>#else</font>
<font color='#009900'>/* Fatal error in PNG image of libpng - can't continue */</font>
<b><a name='PNG_EXPORTA'></a>PNG_EXPORTA</b><font face='Lucida Console'>(</font><font color='#979000'>104</font>, <font color='#0000FF'><u>void</u></font>, png_err, <font face='Lucida Console'>(</font>png_const_structrp png_ptr<font face='Lucida Console'>)</font>, PNG_NORETURN<font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_WARNINGS_SUPPORTED
<font color='#009900'>/* Non-fatal error in libpng.  Can continue, but may have a problem. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>105</font>, <font color='#0000FF'><u>void</u></font>, png_warning, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_const_charp warning_message<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Non-fatal error in libpng, chunk name is prepended to message. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>106</font>, <font color='#0000FF'><u>void</u></font>, png_chunk_warning, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_const_charp warning_message<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_BENIGN_ERRORS_SUPPORTED
<font color='#009900'>/* Benign error in libpng.  Can continue, but may have a problem.
 * User can choose whether to handle as a fatal error or as a warning. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>107</font>, <font color='#0000FF'><u>void</u></font>, png_benign_error, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_const_charp warning_message<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#0000FF'>#ifdef</font> PNG_READ_SUPPORTED
<font color='#009900'>/* Same, chunk name is prepended to message (only during read) */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>108</font>, <font color='#0000FF'><u>void</u></font>, png_chunk_benign_error, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_const_charp warning_message<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>109</font>, <font color='#0000FF'><u>void</u></font>, png_set_benign_errors,
    <font face='Lucida Console'>(</font>png_structrp png_ptr, <font color='#0000FF'><u>int</u></font> allowed<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#else</font>
#  ifdef PNG_ALLOW_BENIGN_ERRORS
#    define png_benign_error png_warning
#    define png_chunk_benign_error png_chunk_warning
#  <font color='#0000FF'>else</font>
#    define png_benign_error png_error
#    define png_chunk_benign_error png_chunk_error
#  endif
<font color='#0000FF'>#endif</font>

<font color='#009900'>/* The png_set_&lt;chunk&gt; functions are for storing values in the png_info_struct.
 * Similarly, the png_get_&lt;chunk&gt; calls are used to read values from the
 * png_info_struct, either storing the parameters in the passed variables, or
 * setting pointers into the png_info_struct where the data is stored.  The
 * png_get_&lt;chunk&gt; functions return a non-zero value if the data was available
 * in info_ptr, or return zero and do not change any of the parameters if the
 * data was not available.
 *
 * These functions should be used instead of directly accessing png_info
 * to avoid problems with future changes in the size and internal layout of
 * png_info_struct.
 */</font>
<font color='#009900'>/* Returns "flag" if chunk data is valid in info_ptr. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>110</font>, png_uint_32, png_get_valid, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_const_inforp info_ptr, png_uint_32 flag<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Returns number of bytes needed to hold a transformed row. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>111</font>, png_size_t, png_get_rowbytes, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_const_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#0000FF'>#ifdef</font> PNG_INFO_IMAGE_SUPPORTED
<font color='#009900'>/* Returns row_pointers, which is an array of pointers to scanlines that was
 * returned from png_read_png().
 */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>112</font>, png_bytepp, png_get_rows, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_const_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Set row_pointers, which is an array of pointers to scanlines for use
 * by png_write_png().
 */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>113</font>, <font color='#0000FF'><u>void</u></font>, png_set_rows, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, png_bytepp row_pointers<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#009900'>/* Returns number of color channels in image. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>114</font>, png_byte, png_get_channels, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_const_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#0000FF'>#ifdef</font> PNG_EASY_ACCESS_SUPPORTED
<font color='#009900'>/* Returns image width in pixels. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>115</font>, png_uint_32, png_get_image_width, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_const_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Returns image height in pixels. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>116</font>, png_uint_32, png_get_image_height, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_const_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Returns image bit_depth. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>117</font>, png_byte, png_get_bit_depth, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_const_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Returns image color_type. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>118</font>, png_byte, png_get_color_type, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_const_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Returns image filter_type. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>119</font>, png_byte, png_get_filter_type, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_const_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Returns image interlace_type. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>120</font>, png_byte, png_get_interlace_type, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_const_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Returns image compression_type. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>121</font>, png_byte, png_get_compression_type, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_const_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Returns image resolution in pixels per meter, from pHYs chunk data. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>122</font>, png_uint_32, png_get_pixels_per_meter,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr, png_const_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>123</font>, png_uint_32, png_get_x_pixels_per_meter,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr, png_const_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>124</font>, png_uint_32, png_get_y_pixels_per_meter,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr, png_const_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Returns pixel aspect ratio, computed from pHYs chunk data.  */</font>
<b><a name='PNG_FP_EXPORT'></a>PNG_FP_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>125</font>, <font color='#0000FF'><u>float</u></font>, png_get_pixel_aspect_ratio,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr, png_const_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<b><a name='PNG_FIXED_EXPORT'></a>PNG_FIXED_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>210</font>, png_fixed_point, png_get_pixel_aspect_ratio_fixed,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr, png_const_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>

<font color='#009900'>/* Returns image x, y offset in pixels or microns, from oFFs chunk data. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>126</font>, png_int_32, png_get_x_offset_pixels,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr, png_const_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>127</font>, png_int_32, png_get_y_offset_pixels,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr, png_const_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>128</font>, png_int_32, png_get_x_offset_microns,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr, png_const_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>129</font>, png_int_32, png_get_y_offset_microns,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr, png_const_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#0000FF'>#endif</font> <font color='#009900'>/* PNG_EASY_ACCESS_SUPPORTED */</font>

<font color='#0000FF'>#ifdef</font> PNG_READ_SUPPORTED
<font color='#009900'>/* Returns pointer to signature string read from PNG header */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>130</font>, png_const_bytep, png_get_signature, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_const_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_bKGD_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>131</font>, png_uint_32, png_get_bKGD, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, png_color_16p <font color='#5555FF'>*</font>background<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_bKGD_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>132</font>, <font color='#0000FF'><u>void</u></font>, png_set_bKGD, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_color_16p background<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_cHRM_SUPPORTED
<b><a name='PNG_FP_EXPORT'></a>PNG_FP_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>133</font>, png_uint_32, png_get_cHRM, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_const_inforp info_ptr, <font color='#0000FF'><u>double</u></font> <font color='#5555FF'>*</font>white_x, <font color='#0000FF'><u>double</u></font> <font color='#5555FF'>*</font>white_y, <font color='#0000FF'><u>double</u></font> <font color='#5555FF'>*</font>red_x,
    <font color='#0000FF'><u>double</u></font> <font color='#5555FF'>*</font>red_y, <font color='#0000FF'><u>double</u></font> <font color='#5555FF'>*</font>green_x, <font color='#0000FF'><u>double</u></font> <font color='#5555FF'>*</font>green_y, <font color='#0000FF'><u>double</u></font> <font color='#5555FF'>*</font>blue_x,
    <font color='#0000FF'><u>double</u></font> <font color='#5555FF'>*</font>blue_y<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<b><a name='PNG_FP_EXPORT'></a>PNG_FP_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>230</font>, png_uint_32, png_get_cHRM_XYZ, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_const_inforp info_ptr, <font color='#0000FF'><u>double</u></font> <font color='#5555FF'>*</font>red_X, <font color='#0000FF'><u>double</u></font> <font color='#5555FF'>*</font>red_Y, <font color='#0000FF'><u>double</u></font> <font color='#5555FF'>*</font>red_Z,
    <font color='#0000FF'><u>double</u></font> <font color='#5555FF'>*</font>green_X, <font color='#0000FF'><u>double</u></font> <font color='#5555FF'>*</font>green_Y, <font color='#0000FF'><u>double</u></font> <font color='#5555FF'>*</font>green_Z, <font color='#0000FF'><u>double</u></font> <font color='#5555FF'>*</font>blue_X,
    <font color='#0000FF'><u>double</u></font> <font color='#5555FF'>*</font>blue_Y, <font color='#0000FF'><u>double</u></font> <font color='#5555FF'>*</font>blue_Z<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<b><a name='PNG_FIXED_EXPORT'></a>PNG_FIXED_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>134</font>, png_uint_32, png_get_cHRM_fixed,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr, png_const_inforp info_ptr,
    png_fixed_point <font color='#5555FF'>*</font>int_white_x, png_fixed_point <font color='#5555FF'>*</font>int_white_y,
    png_fixed_point <font color='#5555FF'>*</font>int_red_x, png_fixed_point <font color='#5555FF'>*</font>int_red_y,
    png_fixed_point <font color='#5555FF'>*</font>int_green_x, png_fixed_point <font color='#5555FF'>*</font>int_green_y,
    png_fixed_point <font color='#5555FF'>*</font>int_blue_x, png_fixed_point <font color='#5555FF'>*</font>int_blue_y<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<b><a name='PNG_FIXED_EXPORT'></a>PNG_FIXED_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>231</font>, png_uint_32, png_get_cHRM_XYZ_fixed,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr, png_const_inforp info_ptr,
    png_fixed_point <font color='#5555FF'>*</font>int_red_X, png_fixed_point <font color='#5555FF'>*</font>int_red_Y,
    png_fixed_point <font color='#5555FF'>*</font>int_red_Z, png_fixed_point <font color='#5555FF'>*</font>int_green_X,
    png_fixed_point <font color='#5555FF'>*</font>int_green_Y, png_fixed_point <font color='#5555FF'>*</font>int_green_Z,
    png_fixed_point <font color='#5555FF'>*</font>int_blue_X, png_fixed_point <font color='#5555FF'>*</font>int_blue_Y,
    png_fixed_point <font color='#5555FF'>*</font>int_blue_Z<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_cHRM_SUPPORTED
<b><a name='PNG_FP_EXPORT'></a>PNG_FP_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>135</font>, <font color='#0000FF'><u>void</u></font>, png_set_cHRM, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr,
    <font color='#0000FF'><u>double</u></font> white_x, <font color='#0000FF'><u>double</u></font> white_y, <font color='#0000FF'><u>double</u></font> red_x, <font color='#0000FF'><u>double</u></font> red_y, <font color='#0000FF'><u>double</u></font> green_x,
    <font color='#0000FF'><u>double</u></font> green_y, <font color='#0000FF'><u>double</u></font> blue_x, <font color='#0000FF'><u>double</u></font> blue_y<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<b><a name='PNG_FP_EXPORT'></a>PNG_FP_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>232</font>, <font color='#0000FF'><u>void</u></font>, png_set_cHRM_XYZ, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, <font color='#0000FF'><u>double</u></font> red_X, <font color='#0000FF'><u>double</u></font> red_Y, <font color='#0000FF'><u>double</u></font> red_Z,
    <font color='#0000FF'><u>double</u></font> green_X, <font color='#0000FF'><u>double</u></font> green_Y, <font color='#0000FF'><u>double</u></font> green_Z, <font color='#0000FF'><u>double</u></font> blue_X,
    <font color='#0000FF'><u>double</u></font> blue_Y, <font color='#0000FF'><u>double</u></font> blue_Z<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<b><a name='PNG_FIXED_EXPORT'></a>PNG_FIXED_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>136</font>, <font color='#0000FF'><u>void</u></font>, png_set_cHRM_fixed, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, png_fixed_point int_white_x,
    png_fixed_point int_white_y, png_fixed_point int_red_x,
    png_fixed_point int_red_y, png_fixed_point int_green_x,
    png_fixed_point int_green_y, png_fixed_point int_blue_x,
    png_fixed_point int_blue_y<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<b><a name='PNG_FIXED_EXPORT'></a>PNG_FIXED_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>233</font>, <font color='#0000FF'><u>void</u></font>, png_set_cHRM_XYZ_fixed, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, png_fixed_point int_red_X, png_fixed_point int_red_Y,
    png_fixed_point int_red_Z, png_fixed_point int_green_X,
    png_fixed_point int_green_Y, png_fixed_point int_green_Z,
    png_fixed_point int_blue_X, png_fixed_point int_blue_Y,
    png_fixed_point int_blue_Z<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_gAMA_SUPPORTED
<b><a name='PNG_FP_EXPORT'></a>PNG_FP_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>137</font>, png_uint_32, png_get_gAMA, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_const_inforp info_ptr, <font color='#0000FF'><u>double</u></font> <font color='#5555FF'>*</font>file_gamma<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<b><a name='PNG_FIXED_EXPORT'></a>PNG_FIXED_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>138</font>, png_uint_32, png_get_gAMA_fixed,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr, png_const_inforp info_ptr,
    png_fixed_point <font color='#5555FF'>*</font>int_file_gamma<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_gAMA_SUPPORTED
<b><a name='PNG_FP_EXPORT'></a>PNG_FP_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>139</font>, <font color='#0000FF'><u>void</u></font>, png_set_gAMA, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, <font color='#0000FF'><u>double</u></font> file_gamma<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<b><a name='PNG_FIXED_EXPORT'></a>PNG_FIXED_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>140</font>, <font color='#0000FF'><u>void</u></font>, png_set_gAMA_fixed, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, png_fixed_point int_file_gamma<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_hIST_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>141</font>, png_uint_32, png_get_hIST, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, png_uint_16p <font color='#5555FF'>*</font>hist<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_hIST_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>142</font>, <font color='#0000FF'><u>void</u></font>, png_set_hIST, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_uint_16p hist<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>143</font>, png_uint_32, png_get_IHDR, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_const_inforp info_ptr, png_uint_32 <font color='#5555FF'>*</font>width, png_uint_32 <font color='#5555FF'>*</font>height,
    <font color='#0000FF'><u>int</u></font> <font color='#5555FF'>*</font>bit_depth, <font color='#0000FF'><u>int</u></font> <font color='#5555FF'>*</font>color_type, <font color='#0000FF'><u>int</u></font> <font color='#5555FF'>*</font>interlace_method,
    <font color='#0000FF'><u>int</u></font> <font color='#5555FF'>*</font>compression_method, <font color='#0000FF'><u>int</u></font> <font color='#5555FF'>*</font>filter_method<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>144</font>, <font color='#0000FF'><u>void</u></font>, png_set_IHDR, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 width, png_uint_32 height, <font color='#0000FF'><u>int</u></font> bit_depth,
    <font color='#0000FF'><u>int</u></font> color_type, <font color='#0000FF'><u>int</u></font> interlace_method, <font color='#0000FF'><u>int</u></font> compression_method,
    <font color='#0000FF'><u>int</u></font> filter_method<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#0000FF'>#ifdef</font> PNG_oFFs_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>145</font>, png_uint_32, png_get_oFFs, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
   png_const_inforp info_ptr, png_int_32 <font color='#5555FF'>*</font>offset_x, png_int_32 <font color='#5555FF'>*</font>offset_y,
   <font color='#0000FF'><u>int</u></font> <font color='#5555FF'>*</font>unit_type<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_oFFs_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>146</font>, <font color='#0000FF'><u>void</u></font>, png_set_oFFs, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, png_int_32 offset_x, png_int_32 offset_y,
    <font color='#0000FF'><u>int</u></font> unit_type<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_pCAL_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>147</font>, png_uint_32, png_get_pCAL, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, png_charp <font color='#5555FF'>*</font>purpose, png_int_32 <font color='#5555FF'>*</font>X0,
    png_int_32 <font color='#5555FF'>*</font>X1, <font color='#0000FF'><u>int</u></font> <font color='#5555FF'>*</font>type, <font color='#0000FF'><u>int</u></font> <font color='#5555FF'>*</font>nparams, png_charp <font color='#5555FF'>*</font>units,
    png_charpp <font color='#5555FF'>*</font>params<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_pCAL_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>148</font>, <font color='#0000FF'><u>void</u></font>, png_set_pCAL, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_charp purpose, png_int_32 X0, png_int_32 X1,
    <font color='#0000FF'><u>int</u></font> type, <font color='#0000FF'><u>int</u></font> nparams, png_const_charp units, png_charpp params<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_pHYs_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>149</font>, png_uint_32, png_get_pHYs, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_const_inforp info_ptr, png_uint_32 <font color='#5555FF'>*</font>res_x, png_uint_32 <font color='#5555FF'>*</font>res_y,
    <font color='#0000FF'><u>int</u></font> <font color='#5555FF'>*</font>unit_type<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_pHYs_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>150</font>, <font color='#0000FF'><u>void</u></font>, png_set_pHYs, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 res_x, png_uint_32 res_y, <font color='#0000FF'><u>int</u></font> unit_type<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>151</font>, png_uint_32, png_get_PLTE, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
   png_inforp info_ptr, png_colorp <font color='#5555FF'>*</font>palette, <font color='#0000FF'><u>int</u></font> <font color='#5555FF'>*</font>num_palette<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>152</font>, <font color='#0000FF'><u>void</u></font>, png_set_PLTE, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    png_inforp info_ptr, png_const_colorp palette, <font color='#0000FF'><u>int</u></font> num_palette<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#0000FF'>#ifdef</font> PNG_sBIT_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>153</font>, png_uint_32, png_get_sBIT, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, png_color_8p <font color='#5555FF'>*</font>sig_bit<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_sBIT_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>154</font>, <font color='#0000FF'><u>void</u></font>, png_set_sBIT, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_color_8p sig_bit<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_sRGB_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>155</font>, png_uint_32, png_get_sRGB, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_const_inforp info_ptr, <font color='#0000FF'><u>int</u></font> <font color='#5555FF'>*</font>file_srgb_intent<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_sRGB_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>156</font>, <font color='#0000FF'><u>void</u></font>, png_set_sRGB, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, <font color='#0000FF'><u>int</u></font> srgb_intent<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>157</font>, <font color='#0000FF'><u>void</u></font>, png_set_sRGB_gAMA_and_cHRM, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, <font color='#0000FF'><u>int</u></font> srgb_intent<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_iCCP_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>158</font>, png_uint_32, png_get_iCCP, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, png_charpp name, <font color='#0000FF'><u>int</u></font> <font color='#5555FF'>*</font>compression_type,
    png_bytepp profile, png_uint_32 <font color='#5555FF'>*</font>proflen<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_iCCP_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>159</font>, <font color='#0000FF'><u>void</u></font>, png_set_iCCP, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_charp name, <font color='#0000FF'><u>int</u></font> compression_type,
    png_const_bytep profile, png_uint_32 proflen<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_sPLT_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>160</font>, <font color='#0000FF'><u>int</u></font>, png_get_sPLT, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, png_sPLT_tpp entries<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_sPLT_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>161</font>, <font color='#0000FF'><u>void</u></font>, png_set_sPLT, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_sPLT_tp entries, <font color='#0000FF'><u>int</u></font> nentries<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_TEXT_SUPPORTED
<font color='#009900'>/* png_get_text also returns the number of text chunks in *num_text */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>162</font>, <font color='#0000FF'><u>int</u></font>, png_get_text, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, png_textp <font color='#5555FF'>*</font>text_ptr, <font color='#0000FF'><u>int</u></font> <font color='#5555FF'>*</font>num_text<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#009900'>/* Note while png_set_text() will accept a structure whose text,
 * language, and  translated keywords are NULL pointers, the structure
 * returned by png_get_text will always contain regular
 * zero-terminated C strings.  They might be empty strings but
 * they will never be NULL pointers.
 */</font>

<font color='#0000FF'>#ifdef</font> PNG_TEXT_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>163</font>, <font color='#0000FF'><u>void</u></font>, png_set_text, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_textp text_ptr, <font color='#0000FF'><u>int</u></font> num_text<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_tIME_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>164</font>, png_uint_32, png_get_tIME, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, png_timep <font color='#5555FF'>*</font>mod_time<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_tIME_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>165</font>, <font color='#0000FF'><u>void</u></font>, png_set_tIME, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_timep mod_time<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_tRNS_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>166</font>, png_uint_32, png_get_tRNS, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, png_bytep <font color='#5555FF'>*</font>trans_alpha, <font color='#0000FF'><u>int</u></font> <font color='#5555FF'>*</font>num_trans,
    png_color_16p <font color='#5555FF'>*</font>trans_color<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_tRNS_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>167</font>, <font color='#0000FF'><u>void</u></font>, png_set_tRNS, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    png_inforp info_ptr, png_const_bytep trans_alpha, <font color='#0000FF'><u>int</u></font> num_trans,
    png_const_color_16p trans_color<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_sCAL_SUPPORTED
<b><a name='PNG_FP_EXPORT'></a>PNG_FP_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>168</font>, png_uint_32, png_get_sCAL, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_const_inforp info_ptr, <font color='#0000FF'><u>int</u></font> <font color='#5555FF'>*</font>unit, <font color='#0000FF'><u>double</u></font> <font color='#5555FF'>*</font>width, <font color='#0000FF'><u>double</u></font> <font color='#5555FF'>*</font>height<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<font color='#0000FF'>#if</font> defined<font face='Lucida Console'>(</font>PNG_FLOATING_ARITHMETIC_SUPPORTED<font face='Lucida Console'>)</font> <font color='#5555FF'>|</font><font color='#5555FF'>|</font> \
   <b><a name='defined'></a>defined</b><font face='Lucida Console'>(</font>PNG_FLOATING_POINT_SUPPORTED<font face='Lucida Console'>)</font>
<font color='#009900'>/* NOTE: this API is currently implemented using floating point arithmetic,
 * consequently it can only be used on systems with floating point support.
 * In any case the range of values supported by png_fixed_point is small and it
 * is highly recommended that png_get_sCAL_s be used instead.
 */</font>
<b><a name='PNG_FIXED_EXPORT'></a>PNG_FIXED_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>214</font>, png_uint_32, png_get_sCAL_fixed,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr, png_const_inforp info_ptr, <font color='#0000FF'><u>int</u></font> <font color='#5555FF'>*</font>unit,
    png_fixed_point <font color='#5555FF'>*</font>width, png_fixed_point <font color='#5555FF'>*</font>height<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<font color='#0000FF'>#endif</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>169</font>, png_uint_32, png_get_sCAL_s,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr, png_const_inforp info_ptr, <font color='#0000FF'><u>int</u></font> <font color='#5555FF'>*</font>unit,
    png_charpp swidth, png_charpp sheight<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<b><a name='PNG_FP_EXPORT'></a>PNG_FP_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>170</font>, <font color='#0000FF'><u>void</u></font>, png_set_sCAL, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, <font color='#0000FF'><u>int</u></font> unit, <font color='#0000FF'><u>double</u></font> width, <font color='#0000FF'><u>double</u></font> height<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<b><a name='PNG_FIXED_EXPORT'></a>PNG_FIXED_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>213</font>, <font color='#0000FF'><u>void</u></font>, png_set_sCAL_fixed, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
   png_inforp info_ptr, <font color='#0000FF'><u>int</u></font> unit, png_fixed_point width,
   png_fixed_point height<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>171</font>, <font color='#0000FF'><u>void</u></font>, png_set_sCAL_s, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, <font color='#0000FF'><u>int</u></font> unit,
    png_const_charp swidth, png_const_charp sheight<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font> <font color='#009900'>/* PNG_sCAL_SUPPORTED */</font>

<font color='#0000FF'>#ifdef</font> PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
<font color='#009900'>/* Provide the default handling for all unknown chunks or, optionally, for
 * specific unknown chunks.
 *
 * NOTE: prior to 1.6.0 the handling specified for particular chunks on read was
 * ignored and the default was used, the per-chunk setting only had an effect on
 * write.  If you wish to have chunk-specific handling on read in code that must
 * work on earlier versions you must use a user chunk callback to specify the
 * desired handling (keep or discard.)
 *
 * The 'keep' parameter is a PNG_HANDLE_CHUNK_ value as listed below.  The
 * parameter is interpreted as follows:
 *
 * READ:
 *    PNG_HANDLE_CHUNK_AS_DEFAULT:
 *       Known chunks: do normal libpng processing, do not keep the chunk (but
 *          see the comments below about PNG_HANDLE_AS_UNKNOWN_SUPPORTED)
 *       Unknown chunks: for a specific chunk use the global default, when used
 *          as the default discard the chunk data.
 *    PNG_HANDLE_CHUNK_NEVER:
 *       Discard the chunk data.
 *    PNG_HANDLE_CHUNK_IF_SAFE:
 *       Keep the chunk data if the chunk is not critical else raise a chunk
 *       error.
 *    PNG_HANDLE_CHUNK_ALWAYS:
 *       Keep the chunk data.
 *
 * If the chunk data is saved it can be retrieved using png_get_unknown_chunks,
 * below.  Notice that specifying "AS_DEFAULT" as a global default is equivalent
 * to specifying "NEVER", however when "AS_DEFAULT" is used for specific chunks
 * it simply resets the behavior to the libpng default.
 *
 * INTERACTION WTIH USER CHUNK CALLBACKS:
 * The per-chunk handling is always used when there is a png_user_chunk_ptr
 * callback and the callback returns 0; the chunk is then always stored *unless*
 * it is critical and the per-chunk setting is other than ALWAYS.  Notice that
 * the global default is *not* used in this case.  (In effect the per-chunk
 * value is incremented to at least IF_SAFE.)
 *
 * IMPORTANT NOTE: this behavior will change in libpng 1.7 - the global and
 * per-chunk defaults will be honored.  If you want to preserve the current
 * behavior when your callback returns 0 you must set PNG_HANDLE_CHUNK_IF_SAFE
 * as the default - if you don't do this libpng 1.6 will issue a warning.
 *
 * If you want unhandled unknown chunks to be discarded in libpng 1.6 and
 * earlier simply return '1' (handled).
 *
 * PNG_HANDLE_AS_UNKNOWN_SUPPORTED:
 *    If this is *not* set known chunks will always be handled by libpng and
 *    will never be stored in the unknown chunk list.  Known chunks listed to
 *    png_set_keep_unknown_chunks will have no effect.  If it is set then known
 *    chunks listed with a keep other than AS_DEFAULT will *never* be processed
 *    by libpng, in addition critical chunks must either be processed by the
 *    callback or saved.
 *
 *    The IHDR and IEND chunks must not be listed.  Because this turns off the
 *    default handling for chunks that would otherwise be recognized the
 *    behavior of libpng transformations may well become incorrect!
 *
 * WRITE:
 *    When writing chunks the options only apply to the chunks specified by
 *    png_set_unknown_chunks (below), libpng will *always* write known chunks
 *    required by png_set_ calls and will always write the core critical chunks
 *    (as required for PLTE).
 *
 *    Each chunk in the png_set_unknown_chunks list is looked up in the
 *    png_set_keep_unknown_chunks list to find the keep setting, this is then
 *    interpreted as follows:
 *
 *    PNG_HANDLE_CHUNK_AS_DEFAULT:
 *       Write safe-to-copy chunks and write other chunks if the global
 *       default is set to _ALWAYS, otherwise don't write this chunk.
 *    PNG_HANDLE_CHUNK_NEVER:
 *       Do not write the chunk.
 *    PNG_HANDLE_CHUNK_IF_SAFE:
 *       Write the chunk if it is safe-to-copy, otherwise do not write it.
 *    PNG_HANDLE_CHUNK_ALWAYS:
 *       Write the chunk.
 *
 * Note that the default behavior is effectively the opposite of the read case -
 * in read unknown chunks are not stored by default, in write they are written
 * by default.  Also the behavior of PNG_HANDLE_CHUNK_IF_SAFE is very different
 * - on write the safe-to-copy bit is checked, on read the critical bit is
 * checked and on read if the chunk is critical an error will be raised.
 *
 * num_chunks:
 * ===========
 *    If num_chunks is positive, then the "keep" parameter specifies the manner
 *    for handling only those chunks appearing in the chunk_list array,
 *    otherwise the chunk list array is ignored.
 *
 *    If num_chunks is 0 the "keep" parameter specifies the default behavior for
 *    unknown chunks, as described above.
 *
 *    If num_chunks is negative, then the "keep" parameter specifies the manner
 *    for handling all unknown chunks plus all chunks recognized by libpng
 *    except for the IHDR, PLTE, tRNS, IDAT, and IEND chunks (which continue to
 *    be processed by libpng.
 */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>172</font>, <font color='#0000FF'><u>void</u></font>, png_set_keep_unknown_chunks, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    <font color='#0000FF'><u>int</u></font> keep, png_const_bytep chunk_list, <font color='#0000FF'><u>int</u></font> num_chunks<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* The "keep" PNG_HANDLE_CHUNK_ parameter for the specified chunk is returned;
 * the result is therefore true (non-zero) if special handling is required,
 * false for the default handling.
 */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>173</font>, <font color='#0000FF'><u>int</u></font>, png_handle_as_unknown, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_const_bytep chunk_name<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>174</font>, <font color='#0000FF'><u>void</u></font>, png_set_unknown_chunks, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_unknown_chunkp unknowns,
    <font color='#0000FF'><u>int</u></font> num_unknowns<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
   <font color='#009900'>/* NOTE: prior to 1.6.0 this routine set the 'location' field of the added
    * unknowns to the location currently stored in the png_struct.  This is
    * invariably the wrong value on write.  To fix this call the following API
    * for each chunk in the list with the correct location.  If you know your
    * code won't be compiled on earlier versions you can rely on
    * png_set_unknown_chunks(write-ptr, png_get_unknown_chunks(read-ptr)) doing
    * the correct thing.
    */</font>

<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>175</font>, <font color='#0000FF'><u>void</u></font>, png_set_unknown_chunk_location,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr, png_inforp info_ptr, <font color='#0000FF'><u>int</u></font> chunk, <font color='#0000FF'><u>int</u></font> location<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>176</font>, <font color='#0000FF'><u>int</u></font>, png_get_unknown_chunks, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, png_unknown_chunkpp entries<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#009900'>/* Png_free_data() will turn off the "valid" flag for anything it frees.
 * If you need to turn it off for a chunk that your application has freed,
 * you can use png_set_invalid(png_ptr, info_ptr, PNG_INFO_CHNK);
 */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>177</font>, <font color='#0000FF'><u>void</u></font>, png_set_invalid, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_inforp info_ptr, <font color='#0000FF'><u>int</u></font> mask<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#0000FF'>#ifdef</font> PNG_INFO_IMAGE_SUPPORTED
<font color='#009900'>/* The "params" pointer is currently not used and is for future expansion. */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>178</font>, <font color='#0000FF'><u>void</u></font>, png_read_png, <font face='Lucida Console'>(</font>png_structrp png_ptr, png_inforp info_ptr,
    <font color='#0000FF'><u>int</u></font> transforms, png_voidp params<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>179</font>, <font color='#0000FF'><u>void</u></font>, png_write_png, <font face='Lucida Console'>(</font>png_structrp png_ptr, png_inforp info_ptr,
    <font color='#0000FF'><u>int</u></font> transforms, png_voidp params<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>180</font>, png_const_charp, png_get_copyright,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>181</font>, png_const_charp, png_get_header_ver,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>182</font>, png_const_charp, png_get_header_version,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>183</font>, png_const_charp, png_get_libpng_ver,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#0000FF'>#ifdef</font> PNG_MNG_FEATURES_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>184</font>, png_uint_32, png_permit_mng_features, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    png_uint_32 mng_features_permitted<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#009900'>/* For use in png_set_keep_unknown, added to version 1.2.6 */</font>
<font color='#0000FF'>#define</font> PNG_HANDLE_CHUNK_AS_DEFAULT   <font color='#979000'>0</font>
<font color='#0000FF'>#define</font> PNG_HANDLE_CHUNK_NEVER        <font color='#979000'>1</font>
<font color='#0000FF'>#define</font> PNG_HANDLE_CHUNK_IF_SAFE      <font color='#979000'>2</font>
<font color='#0000FF'>#define</font> PNG_HANDLE_CHUNK_ALWAYS       <font color='#979000'>3</font>
<font color='#0000FF'>#define</font> PNG_HANDLE_CHUNK_LAST         <font color='#979000'>4</font>

<font color='#009900'>/* Strip the prepended error numbers ("#nnn ") from error and warning
 * messages before passing them to the error or warning handler.
 */</font>
<font color='#0000FF'>#ifdef</font> PNG_ERROR_NUMBERS_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>185</font>, <font color='#0000FF'><u>void</u></font>, png_set_strip_error_numbers, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    png_uint_32 strip_mode<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#009900'>/* Added in libpng-1.2.6 */</font>
<font color='#0000FF'>#ifdef</font> PNG_SET_USER_LIMITS_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>186</font>, <font color='#0000FF'><u>void</u></font>, png_set_user_limits, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    png_uint_32 user_width_max, png_uint_32 user_height_max<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>187</font>, png_uint_32, png_get_user_width_max,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>188</font>, png_uint_32, png_get_user_height_max,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#009900'>/* Added in libpng-1.4.0 */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>189</font>, <font color='#0000FF'><u>void</u></font>, png_set_chunk_cache_max, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    png_uint_32 user_chunk_cache_max<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>190</font>, png_uint_32, png_get_chunk_cache_max,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#009900'>/* Added in libpng-1.4.1 */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>191</font>, <font color='#0000FF'><u>void</u></font>, png_set_chunk_malloc_max, <font face='Lucida Console'>(</font>png_structrp png_ptr,
    png_alloc_size_t user_chunk_cache_max<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>192</font>, png_alloc_size_t, png_get_chunk_malloc_max,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#if</font> defined<font face='Lucida Console'>(</font>PNG_INCH_CONVERSIONS_SUPPORTED<font face='Lucida Console'>)</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>193</font>, png_uint_32, png_get_pixels_per_inch,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr, png_const_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>194</font>, png_uint_32, png_get_x_pixels_per_inch,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr, png_const_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>195</font>, png_uint_32, png_get_y_pixels_per_inch,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr, png_const_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<b><a name='PNG_FP_EXPORT'></a>PNG_FP_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>196</font>, <font color='#0000FF'><u>float</u></font>, png_get_x_offset_inches,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr, png_const_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<font color='#0000FF'>#ifdef</font> PNG_FIXED_POINT_SUPPORTED <font color='#009900'>/* otherwise not implemented. */</font>
<b><a name='PNG_FIXED_EXPORT'></a>PNG_FIXED_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>211</font>, png_fixed_point, png_get_x_offset_inches_fixed,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr, png_const_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<font color='#0000FF'>#endif</font>

<b><a name='PNG_FP_EXPORT'></a>PNG_FP_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>197</font>, <font color='#0000FF'><u>float</u></font>, png_get_y_offset_inches, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_const_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<font color='#0000FF'>#ifdef</font> PNG_FIXED_POINT_SUPPORTED <font color='#009900'>/* otherwise not implemented. */</font>
<b><a name='PNG_FIXED_EXPORT'></a>PNG_FIXED_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>212</font>, png_fixed_point, png_get_y_offset_inches_fixed,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr, png_const_inforp info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<font color='#0000FF'>#endif</font>

#  ifdef PNG_pHYs_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>198</font>, png_uint_32, png_get_pHYs_dpi, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_const_inforp info_ptr, png_uint_32 <font color='#5555FF'>*</font>res_x, png_uint_32 <font color='#5555FF'>*</font>res_y,
    <font color='#0000FF'><u>int</u></font> <font color='#5555FF'>*</font>unit_type<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
#  endif <font color='#009900'>/* PNG_pHYs_SUPPORTED */</font>
<font color='#0000FF'>#endif</font>  <font color='#009900'>/* PNG_INCH_CONVERSIONS_SUPPORTED */</font>

<font color='#009900'>/* Added in libpng-1.4.0 */</font>
<font color='#0000FF'>#ifdef</font> PNG_IO_STATE_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>199</font>, png_uint_32, png_get_io_state, <font face='Lucida Console'>(</font>png_const_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* Removed from libpng 1.6; use png_get_io_chunk_type. */</font>
<b><a name='PNG_REMOVED'></a>PNG_REMOVED</b><font face='Lucida Console'>(</font><font color='#979000'>200</font>, png_const_bytep, png_get_io_chunk_name, <font face='Lucida Console'>(</font>png_structrp png_ptr<font face='Lucida Console'>)</font>,
    PNG_DEPRECATED<font face='Lucida Console'>)</font>

<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>216</font>, png_uint_32, png_get_io_chunk_type,
    <font face='Lucida Console'>(</font>png_const_structrp png_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;

<font color='#009900'>/* The flags returned by png_get_io_state() are the following: */</font>
#  define PNG_IO_NONE        <font color='#979000'>0x0000</font>   <font color='#009900'>/* no I/O at this moment */</font>
#  define PNG_IO_READING     <font color='#979000'>0x0001</font>   <font color='#009900'>/* currently reading */</font>
#  define PNG_IO_WRITING     <font color='#979000'>0x0002</font>   <font color='#009900'>/* currently writing */</font>
#  define PNG_IO_SIGNATURE   <font color='#979000'>0x0010</font>   <font color='#009900'>/* currently at the file signature */</font>
#  define PNG_IO_CHUNK_HDR   <font color='#979000'>0x0020</font>   <font color='#009900'>/* currently at the chunk header */</font>
#  define PNG_IO_CHUNK_DATA  <font color='#979000'>0x0040</font>   <font color='#009900'>/* currently at the chunk data */</font>
#  define PNG_IO_CHUNK_CRC   <font color='#979000'>0x0080</font>   <font color='#009900'>/* currently at the chunk crc */</font>
#  define PNG_IO_MASK_OP     <font color='#979000'>0x000f</font>   <font color='#009900'>/* current operation: reading/writing */</font>
#  define PNG_IO_MASK_LOC    <font color='#979000'>0x00f0</font>   <font color='#009900'>/* current location: sig/hdr/data/crc */</font>
<font color='#0000FF'>#endif</font> <font color='#009900'>/* ?PNG_IO_STATE_SUPPORTED */</font>

<font color='#009900'>/* Interlace support.  The following macros are always defined so that if
 * libpng interlace handling is turned off the macros may be used to handle
 * interlaced images within the application.
 */</font>
<font color='#0000FF'>#define</font> PNG_INTERLACE_ADAM7_PASSES <font color='#979000'>7</font>

<font color='#009900'>/* Two macros to return the first row and first column of the original,
 * full, image which appears in a given pass.  'pass' is in the range 0
 * to 6 and the result is in the range 0 to 7.
 */</font>
<font color='#0000FF'>#define</font> PNG_PASS_START_ROW<font face='Lucida Console'>(</font>pass<font face='Lucida Console'>)</font> <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font color='#979000'>1</font><font color='#5555FF'>&amp;</font>~<font face='Lucida Console'>(</font>pass<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font color='#5555FF'>&lt;</font><font color='#5555FF'>&lt;</font><font face='Lucida Console'>(</font><font color='#979000'>3</font><font color='#5555FF'>-</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>pass<font face='Lucida Console'>)</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#979000'>1</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font color='#5555FF'>&amp;</font><font color='#979000'>7</font><font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PNG_PASS_START_COL<font face='Lucida Console'>(</font>pass<font face='Lucida Console'>)</font> <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font color='#979000'>1</font><font color='#5555FF'>&amp;</font> <font face='Lucida Console'>(</font>pass<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font color='#5555FF'>&lt;</font><font color='#5555FF'>&lt;</font><font face='Lucida Console'>(</font><font color='#979000'>3</font><font color='#5555FF'>-</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>pass<font face='Lucida Console'>)</font><font color='#5555FF'>+</font><font color='#979000'>1</font><font face='Lucida Console'>)</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#979000'>1</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font color='#5555FF'>&amp;</font><font color='#979000'>7</font><font face='Lucida Console'>)</font>

<font color='#009900'>/* A macro to return the offset between pixels in the output row for a pair of
 * pixels in the input - effectively the inverse of the 'COL_SHIFT' macro that
 * follows.  Note that ROW_OFFSET is the offset from one row to the next whereas
 * COL_OFFSET is from one column to the next, within a row.
 */</font>
<font color='#0000FF'>#define</font> PNG_PASS_ROW_OFFSET<font face='Lucida Console'>(</font>pass<font face='Lucida Console'>)</font> <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>pass<font face='Lucida Console'>)</font><font color='#5555FF'>&gt;</font><font color='#979000'>2</font>?<font face='Lucida Console'>(</font><font color='#979000'>8</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>pass<font face='Lucida Console'>)</font><font color='#5555FF'>-</font><font color='#979000'>1</font><font face='Lucida Console'>)</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#979000'>1</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>:<font color='#979000'>8</font><font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PNG_PASS_COL_OFFSET<font face='Lucida Console'>(</font>pass<font face='Lucida Console'>)</font> <font face='Lucida Console'>(</font><font color='#979000'>1</font><font color='#5555FF'>&lt;</font><font color='#5555FF'>&lt;</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font color='#979000'>7</font><font color='#5555FF'>-</font><font face='Lucida Console'>(</font>pass<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#979000'>1</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>

<font color='#009900'>/* Two macros to help evaluate the number of rows or columns in each
 * pass.  This is expressed as a shift - effectively log2 of the number or
 * rows or columns in each 8x8 tile of the original image.
 */</font>
<font color='#0000FF'>#define</font> PNG_PASS_ROW_SHIFT<font face='Lucida Console'>(</font>pass<font face='Lucida Console'>)</font> <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>pass<font face='Lucida Console'>)</font><font color='#5555FF'>&gt;</font><font color='#979000'>2</font>?<font face='Lucida Console'>(</font><font color='#979000'>8</font><font color='#5555FF'>-</font><font face='Lucida Console'>(</font>pass<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#979000'>1</font>:<font color='#979000'>3</font><font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PNG_PASS_COL_SHIFT<font face='Lucida Console'>(</font>pass<font face='Lucida Console'>)</font> <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>pass<font face='Lucida Console'>)</font><font color='#5555FF'>&gt;</font><font color='#979000'>1</font>?<font face='Lucida Console'>(</font><font color='#979000'>7</font><font color='#5555FF'>-</font><font face='Lucida Console'>(</font>pass<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#979000'>1</font>:<font color='#979000'>3</font><font face='Lucida Console'>)</font>

<font color='#009900'>/* Hence two macros to determine the number of rows or columns in a given
 * pass of an image given its height or width.  In fact these macros may
 * return non-zero even though the sub-image is empty, because the other
 * dimension may be empty for a small image.
 */</font>
<font color='#0000FF'>#define</font> PNG_PASS_ROWS<font face='Lucida Console'>(</font>height, pass<font face='Lucida Console'>)</font> <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>height<font face='Lucida Console'>)</font><font color='#5555FF'>+</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font color='#979000'>1</font><font color='#5555FF'>&lt;</font><font color='#5555FF'>&lt;</font>PNG_PASS_ROW_SHIFT<font face='Lucida Console'>(</font>pass<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>\
   <font color='#5555FF'>-</font><font color='#979000'>1</font><font face='Lucida Console'>)</font><font color='#5555FF'>-</font><font color='#BB00BB'>PNG_PASS_START_ROW</font><font face='Lucida Console'>(</font>pass<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#BB00BB'>PNG_PASS_ROW_SHIFT</font><font face='Lucida Console'>(</font>pass<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PNG_PASS_COLS<font face='Lucida Console'>(</font>width, pass<font face='Lucida Console'>)</font> <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>width<font face='Lucida Console'>)</font><font color='#5555FF'>+</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font color='#979000'>1</font><font color='#5555FF'>&lt;</font><font color='#5555FF'>&lt;</font>PNG_PASS_COL_SHIFT<font face='Lucida Console'>(</font>pass<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>\
   <font color='#5555FF'>-</font><font color='#979000'>1</font><font face='Lucida Console'>)</font><font color='#5555FF'>-</font><font color='#BB00BB'>PNG_PASS_START_COL</font><font face='Lucida Console'>(</font>pass<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font color='#BB00BB'>PNG_PASS_COL_SHIFT</font><font face='Lucida Console'>(</font>pass<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>

<font color='#009900'>/* For the reader row callbacks (both progressive and sequential) it is
 * necessary to find the row in the output image given a row in an interlaced
 * image, so two more macros:
 */</font>
<font color='#0000FF'>#define</font> PNG_ROW_FROM_PASS_ROW<font face='Lucida Console'>(</font>y_in, pass<font face='Lucida Console'>)</font> \
   <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>y_in<font face='Lucida Console'>)</font><font color='#5555FF'>&lt;</font><font color='#5555FF'>&lt;</font><font color='#BB00BB'>PNG_PASS_ROW_SHIFT</font><font face='Lucida Console'>(</font>pass<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font color='#5555FF'>+</font><font color='#BB00BB'>PNG_PASS_START_ROW</font><font face='Lucida Console'>(</font>pass<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PNG_COL_FROM_PASS_COL<font face='Lucida Console'>(</font>x_in, pass<font face='Lucida Console'>)</font> \
   <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>x_in<font face='Lucida Console'>)</font><font color='#5555FF'>&lt;</font><font color='#5555FF'>&lt;</font><font color='#BB00BB'>PNG_PASS_COL_SHIFT</font><font face='Lucida Console'>(</font>pass<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font color='#5555FF'>+</font><font color='#BB00BB'>PNG_PASS_START_COL</font><font face='Lucida Console'>(</font>pass<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>

<font color='#009900'>/* Two macros which return a boolean (0 or 1) saying whether the given row
 * or column is in a particular pass.  These use a common utility macro that
 * returns a mask for a given pass - the offset 'off' selects the row or
 * column version.  The mask has the appropriate bit set for each column in
 * the tile.
 */</font>
<font color='#0000FF'>#define</font> PNG_PASS_MASK<font face='Lucida Console'>(</font>pass,off<font face='Lucida Console'>)</font> <font face='Lucida Console'>(</font> \
   <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font color='#979000'>0x110145AF</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font color='#979000'>7</font><font color='#5555FF'>-</font><font face='Lucida Console'>(</font>off<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font color='#5555FF'>-</font><font face='Lucida Console'>(</font>pass<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font color='#5555FF'>&lt;</font><font color='#5555FF'>&lt;</font><font color='#979000'>2</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font> <font color='#5555FF'>&amp;</font> <font color='#979000'>0xF</font><font face='Lucida Console'>)</font> <font color='#5555FF'>|</font> \
   <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font color='#979000'>0x01145AF0</font><font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font color='#979000'>7</font><font color='#5555FF'>-</font><font face='Lucida Console'>(</font>off<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font color='#5555FF'>-</font><font face='Lucida Console'>(</font>pass<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font color='#5555FF'>&lt;</font><font color='#5555FF'>&lt;</font><font color='#979000'>2</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font> <font color='#5555FF'>&amp;</font> <font color='#979000'>0xF0</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>

<font color='#0000FF'>#define</font> PNG_ROW_IN_INTERLACE_PASS<font face='Lucida Console'>(</font>y, pass<font face='Lucida Console'>)</font> \
   <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font color='#BB00BB'>PNG_PASS_MASK</font><font face='Lucida Console'>(</font>pass,<font color='#979000'>0</font><font face='Lucida Console'>)</font> <font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font> <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>y<font face='Lucida Console'>)</font><font color='#5555FF'>&amp;</font><font color='#979000'>7</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font> <font color='#5555FF'>&amp;</font> <font color='#979000'>1</font><font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PNG_COL_IN_INTERLACE_PASS<font face='Lucida Console'>(</font>x, pass<font face='Lucida Console'>)</font> \
   <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font color='#BB00BB'>PNG_PASS_MASK</font><font face='Lucida Console'>(</font>pass,<font color='#979000'>1</font><font face='Lucida Console'>)</font> <font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font> <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>x<font face='Lucida Console'>)</font><font color='#5555FF'>&amp;</font><font color='#979000'>7</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font> <font color='#5555FF'>&amp;</font> <font color='#979000'>1</font><font face='Lucida Console'>)</font>

<font color='#0000FF'>#ifdef</font> PNG_READ_COMPOSITE_NODIV_SUPPORTED
<font color='#009900'>/* With these routines we avoid an integer divide, which will be slower on
 * most machines.  However, it does take more operations than the corresponding
 * divide method, so it may be slower on a few RISC systems.  There are two
 * shifts (by 8 or 16 bits) and an addition, versus a single integer divide.
 *
 * Note that the rounding factors are NOT supposed to be the same!  128 and
 * 32768 are correct for the NODIV code; 127 and 32767 are correct for the
 * standard method.
 *
 * [Optimized code by Greg Roelofs and Mark Adler...blame us for bugs. :-) ]
 */</font>

 <font color='#009900'>/* fg and bg should be in `gamma 1.0' space; alpha is the opacity */</font>

#  define <b><a name='png_composite'></a>png_composite</b><font face='Lucida Console'>(</font>composite, fg, alpha, bg<font face='Lucida Console'>)</font>         \
     <b>{</b> png_uint_16 temp <font color='#5555FF'>=</font> <font face='Lucida Console'>(</font>png_uint_16<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>png_uint_16<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font>fg<font face='Lucida Console'>)</font> \
           <font color='#5555FF'>*</font> <font face='Lucida Console'>(</font>png_uint_16<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font>alpha<font face='Lucida Console'>)</font>                         \
           <font color='#5555FF'>+</font> <font face='Lucida Console'>(</font>png_uint_16<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font>bg<font face='Lucida Console'>)</font><font color='#5555FF'>*</font><font face='Lucida Console'>(</font>png_uint_16<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font><font color='#979000'>255</font>          \
           <font color='#5555FF'>-</font> <font face='Lucida Console'>(</font>png_uint_16<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font>alpha<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font> <font color='#5555FF'>+</font> <font color='#979000'>128</font><font face='Lucida Console'>)</font>;                \
       <font face='Lucida Console'>(</font>composite<font face='Lucida Console'>)</font> <font color='#5555FF'>=</font> <font face='Lucida Console'>(</font>png_byte<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>temp <font color='#5555FF'>+</font> <font face='Lucida Console'>(</font>temp <font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font> <font color='#979000'>8</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font> <font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font> <font color='#979000'>8</font><font face='Lucida Console'>)</font>; <b>}</b>

#  define <b><a name='png_composite_16'></a>png_composite_16</b><font face='Lucida Console'>(</font>composite, fg, alpha, bg<font face='Lucida Console'>)</font>       \
     <b>{</b> png_uint_32 temp <font color='#5555FF'>=</font> <font face='Lucida Console'>(</font>png_uint_32<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>png_uint_32<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font>fg<font face='Lucida Console'>)</font>  \
           <font color='#5555FF'>*</font> <font face='Lucida Console'>(</font>png_uint_32<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font>alpha<font face='Lucida Console'>)</font>                          \
           <font color='#5555FF'>+</font> <font face='Lucida Console'>(</font>png_uint_32<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font>bg<font face='Lucida Console'>)</font><font color='#5555FF'>*</font><font face='Lucida Console'>(</font><font color='#979000'>65535</font>                      \
           <font color='#5555FF'>-</font> <font face='Lucida Console'>(</font>png_uint_32<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font>alpha<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font> <font color='#5555FF'>+</font> <font color='#979000'>32768</font><font face='Lucida Console'>)</font>;               \
       <font face='Lucida Console'>(</font>composite<font face='Lucida Console'>)</font> <font color='#5555FF'>=</font> <font face='Lucida Console'>(</font>png_uint_16<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>temp <font color='#5555FF'>+</font> <font face='Lucida Console'>(</font>temp <font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font> <font color='#979000'>16</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font> <font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font> <font color='#979000'>16</font><font face='Lucida Console'>)</font>; <b>}</b>

<font color='#0000FF'>#else</font>  <font color='#009900'>/* Standard method using integer division */</font>

#  define <b><a name='png_composite'></a>png_composite</b><font face='Lucida Console'>(</font>composite, fg, alpha, bg<font face='Lucida Console'>)</font>                          \
     <font face='Lucida Console'>(</font>composite<font face='Lucida Console'>)</font> <font color='#5555FF'>=</font> <font face='Lucida Console'>(</font>png_byte<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>png_uint_16<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font>fg<font face='Lucida Console'>)</font> <font color='#5555FF'>*</font> <font face='Lucida Console'>(</font>png_uint_16<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font>alpha<font face='Lucida Console'>)</font> <font color='#5555FF'>+</font>  \
     <font face='Lucida Console'>(</font>png_uint_16<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font>bg<font face='Lucida Console'>)</font> <font color='#5555FF'>*</font> <font face='Lucida Console'>(</font>png_uint_16<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font><font color='#979000'>255</font> <font color='#5555FF'>-</font> <font face='Lucida Console'>(</font>png_uint_16<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font>alpha<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font> <font color='#5555FF'>+</font>       \
     <font color='#979000'>127</font><font face='Lucida Console'>)</font> <font color='#5555FF'>/</font> <font color='#979000'>255</font><font face='Lucida Console'>)</font>

#  define <b><a name='png_composite_16'></a>png_composite_16</b><font face='Lucida Console'>(</font>composite, fg, alpha, bg<font face='Lucida Console'>)</font>                         \
     <font face='Lucida Console'>(</font>composite<font face='Lucida Console'>)</font> <font color='#5555FF'>=</font> <font face='Lucida Console'>(</font>png_uint_16<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>png_uint_32<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font>fg<font face='Lucida Console'>)</font> <font color='#5555FF'>*</font> <font face='Lucida Console'>(</font>png_uint_32<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font>alpha<font face='Lucida Console'>)</font> <font color='#5555FF'>+</font> \
     <font face='Lucida Console'>(</font>png_uint_32<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font>bg<font face='Lucida Console'>)</font><font color='#5555FF'>*</font><font face='Lucida Console'>(</font>png_uint_32<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font><font color='#979000'>65535</font> <font color='#5555FF'>-</font> <font face='Lucida Console'>(</font>png_uint_32<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font>alpha<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font> <font color='#5555FF'>+</font>         \
     <font color='#979000'>32767</font><font face='Lucida Console'>)</font> <font color='#5555FF'>/</font> <font color='#979000'>65535</font><font face='Lucida Console'>)</font>
<font color='#0000FF'>#endif</font> <font color='#009900'>/* PNG_READ_COMPOSITE_NODIV_SUPPORTED */</font>

<font color='#0000FF'>#ifdef</font> PNG_READ_INT_FUNCTIONS_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>201</font>, png_uint_32, png_get_uint_32, <font face='Lucida Console'>(</font>png_const_bytep buf<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>202</font>, png_uint_16, png_get_uint_16, <font face='Lucida Console'>(</font>png_const_bytep buf<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>203</font>, png_int_32, png_get_int_32, <font face='Lucida Console'>(</font>png_const_bytep buf<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>204</font>, png_uint_32, png_get_uint_31, <font face='Lucida Console'>(</font>png_const_structrp png_ptr,
    png_const_bytep buf<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#009900'>/* No png_get_int_16 -- may be added if there's a real need for it. */</font>

<font color='#009900'>/* Place a 32-bit number into a buffer in PNG byte order (big-endian). */</font>
<font color='#0000FF'>#ifdef</font> PNG_WRITE_INT_FUNCTIONS_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>205</font>, <font color='#0000FF'><u>void</u></font>, png_save_uint_32, <font face='Lucida Console'>(</font>png_bytep buf, png_uint_32 i<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>
<font color='#0000FF'>#ifdef</font> PNG_SAVE_INT_32_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>206</font>, <font color='#0000FF'><u>void</u></font>, png_save_int_32, <font face='Lucida Console'>(</font>png_bytep buf, png_int_32 i<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#009900'>/* Place a 16-bit number into a buffer in PNG byte order.
 * The parameter is declared unsigned int, not png_uint_16,
 * just to avoid potential problems on pre-ANSI C compilers.
 */</font>
<font color='#0000FF'>#ifdef</font> PNG_WRITE_INT_FUNCTIONS_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>207</font>, <font color='#0000FF'><u>void</u></font>, png_save_uint_16, <font face='Lucida Console'>(</font>png_bytep buf, <font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>int</u></font> i<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#009900'>/* No png_save_int_16 -- may be added if there's a real need for it. */</font>
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_USE_READ_MACROS
<font color='#009900'>/* Inline macros to do direct reads of bytes from the input buffer.
 * The png_get_int_32() routine assumes we are using two's complement
 * format for negative values, which is almost certainly true.
 */</font>
#  define <b><a name='PNG_get_uint_32'></a>PNG_get_uint_32</b><font face='Lucida Console'>(</font>buf<font face='Lucida Console'>)</font> \
     <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>png_uint_32<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font><font color='#5555FF'>*</font><font face='Lucida Console'>(</font>buf<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font> <font color='#5555FF'>&lt;</font><font color='#5555FF'>&lt;</font> <font color='#979000'>24</font><font face='Lucida Console'>)</font> <font color='#5555FF'>+</font> \
      <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>png_uint_32<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font><font color='#5555FF'>*</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>buf<font face='Lucida Console'>)</font> <font color='#5555FF'>+</font> <font color='#979000'>1</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font> <font color='#5555FF'>&lt;</font><font color='#5555FF'>&lt;</font> <font color='#979000'>16</font><font face='Lucida Console'>)</font> <font color='#5555FF'>+</font> \
      <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>png_uint_32<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font><font color='#5555FF'>*</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>buf<font face='Lucida Console'>)</font> <font color='#5555FF'>+</font> <font color='#979000'>2</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font> <font color='#5555FF'>&lt;</font><font color='#5555FF'>&lt;</font> <font color='#979000'>8</font><font face='Lucida Console'>)</font> <font color='#5555FF'>+</font> \
      <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>png_uint_32<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font><font color='#5555FF'>*</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>buf<font face='Lucida Console'>)</font> <font color='#5555FF'>+</font> <font color='#979000'>3</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>

   <font color='#009900'>/* From libpng-1.4.0 until 1.4.4, the png_get_uint_16 macro (but not the
    * function) incorrectly returned a value of type png_uint_32.
    */</font>
#  define <b><a name='PNG_get_uint_16'></a>PNG_get_uint_16</b><font face='Lucida Console'>(</font>buf<font face='Lucida Console'>)</font> \
     <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>png_uint_16<font face='Lucida Console'>)</font> \
      <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>int</u></font><font face='Lucida Console'>)</font><font face='Lucida Console'>(</font><font color='#5555FF'>*</font><font face='Lucida Console'>(</font>buf<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font> <font color='#5555FF'>&lt;</font><font color='#5555FF'>&lt;</font> <font color='#979000'>8</font><font face='Lucida Console'>)</font> <font color='#5555FF'>+</font> \
       <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>int</u></font><font face='Lucida Console'>)</font><font face='Lucida Console'>(</font><font color='#5555FF'>*</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>buf<font face='Lucida Console'>)</font> <font color='#5555FF'>+</font> <font color='#979000'>1</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>

#  define <b><a name='PNG_get_int_32'></a>PNG_get_int_32</b><font face='Lucida Console'>(</font>buf<font face='Lucida Console'>)</font> \
     <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>png_int_32<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font color='#5555FF'>*</font><font face='Lucida Console'>(</font>buf<font face='Lucida Console'>)</font> <font color='#5555FF'>&amp;</font> <font color='#979000'>0x80</font><font face='Lucida Console'>)</font> \
      ? <font color='#5555FF'>-</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>png_int_32<font face='Lucida Console'>)</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font color='#BB00BB'>png_get_uint_32</font><font face='Lucida Console'>(</font>buf<font face='Lucida Console'>)</font> ^ <font color='#979000'>0xffffffffL</font><font face='Lucida Console'>)</font> <font color='#5555FF'>+</font> <font color='#979000'>1</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font> \
      : <font face='Lucida Console'>(</font>png_int_32<font face='Lucida Console'>)</font><font color='#BB00BB'>png_get_uint_32</font><font face='Lucida Console'>(</font>buf<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>

   <font color='#009900'>/* If PNG_PREFIX is defined the same thing as below happens in pnglibconf.h,
    * but defining a macro name prefixed with PNG_PREFIX.
    */</font>
#  ifndef PNG_PREFIX
#     define <b><a name='png_get_uint_32'></a>png_get_uint_32</b><font face='Lucida Console'>(</font>buf<font face='Lucida Console'>)</font> <b><a name='PNG_get_uint_32'></a>PNG_get_uint_32</b><font face='Lucida Console'>(</font>buf<font face='Lucida Console'>)</font>
#     define <b><a name='png_get_uint_16'></a>png_get_uint_16</b><font face='Lucida Console'>(</font>buf<font face='Lucida Console'>)</font> <b><a name='PNG_get_uint_16'></a>PNG_get_uint_16</b><font face='Lucida Console'>(</font>buf<font face='Lucida Console'>)</font>
#     define <b><a name='png_get_int_32'></a>png_get_int_32</b><font face='Lucida Console'>(</font>buf<font face='Lucida Console'>)</font>  <b><a name='PNG_get_int_32'></a>PNG_get_int_32</b><font face='Lucida Console'>(</font>buf<font face='Lucida Console'>)</font>
#  endif
<font color='#0000FF'>#else</font>
#  ifdef PNG_PREFIX
      <font color='#009900'>/* No macros; revert to the (redefined) function */</font>
#     define <b><a name='PNG_get_uint_32'></a>PNG_get_uint_32</b> <font face='Lucida Console'>(</font>png_get_uint_32<font face='Lucida Console'>)</font>
#     define <b><a name='PNG_get_uint_16'></a>PNG_get_uint_16</b> <font face='Lucida Console'>(</font>png_get_uint_16<font face='Lucida Console'>)</font>
#     define <b><a name='PNG_get_int_32'></a>PNG_get_int_32</b>  <font face='Lucida Console'>(</font>png_get_int_32<font face='Lucida Console'>)</font>
#  endif
<font color='#0000FF'>#endif</font>

<font color='#009900'>/*******************************************************************************
 *  SIMPLIFIED API
 *******************************************************************************
 *
 * Please read the documentation in libpng-manual.txt (TODO: write said
 * documentation) if you don't understand what follows.
 *
 * The simplified API hides the details of both libpng and the PNG file format
 * itself.  It allows PNG files to be read into a very limited number of
 * in-memory bitmap formats or to be written from the same formats.  If these
 * formats do not accomodate your needs then you can, and should, use the more
 * sophisticated APIs above - these support a wide variety of in-memory formats
 * and a wide variety of sophisticated transformations to those formats as well
 * as a wide variety of APIs to manipulate ancillary information.
 *
 * To read a PNG file using the simplified API:
 *
 * 1) Declare a 'png_image' structure (see below) on the stack and set the
 *    version field to PNG_IMAGE_VERSION.
 * 2) Call the appropriate png_image_begin_read... function.
 * 3) Set the png_image 'format' member to the required sample format.
 * 4) Allocate a buffer for the image and, if required, the color-map.
 * 5) Call png_image_finish_read to read the image and, if required, the
 *    color-map into your buffers.
 *
 * There are no restrictions on the format of the PNG input itself; all valid
 * color types, bit depths, and interlace methods are acceptable, and the
 * input image is transformed as necessary to the requested in-memory format
 * during the png_image_finish_read() step.  The only caveat is that if you
 * request a color-mapped image from a PNG that is full-color or makes
 * complex use of an alpha channel the transformation is extremely lossy and the
 * result may look terrible.
 *
 * To write a PNG file using the simplified API:
 *
 * 1) Declare a 'png_image' structure on the stack and memset() it to all zero.
 * 2) Initialize the members of the structure that describe the image, setting
 *    the 'format' member to the format of the image samples.
 * 3) Call the appropriate png_image_write... function with a pointer to the
 *    image and, if necessary, the color-map to write the PNG data.
 *
 * png_image is a structure that describes the in-memory format of an image
 * when it is being read or defines the in-memory format of an image that you
 * need to write:
 */</font>
<font color='#0000FF'>#define</font> PNG_IMAGE_VERSION <font color='#979000'>1</font>

<font color='#0000FF'>typedef</font> <font color='#0000FF'>struct</font> png_control <font color='#5555FF'>*</font>png_controlp;
<font color='#0000FF'>typedef</font> <font color='#0000FF'>struct</font>
<b>{</b>
   png_controlp opaque;    <font color='#009900'>/* Initialize to NULL, free with png_image_free */</font>
   png_uint_32  version;   <font color='#009900'>/* Set to PNG_IMAGE_VERSION */</font>
   png_uint_32  width;     <font color='#009900'>/* Image width in pixels (columns) */</font>
   png_uint_32  height;    <font color='#009900'>/* Image height in pixels (rows) */</font>
   png_uint_32  format;    <font color='#009900'>/* Image format as defined below */</font>
   png_uint_32  flags;     <font color='#009900'>/* A bit mask containing informational flags */</font>
   png_uint_32  colormap_entries;
                           <font color='#009900'>/* Number of entries in the color-map */</font>

   <font color='#009900'>/* In the event of an error or warning the following field will be set to a
    * non-zero value and the 'message' field will contain a '\0' terminated
    * string with the libpng error or warning message.  If both warnings and
    * an error were encountered, only the error is recorded.  If there
    * are multiple warnings, only the first one is recorded.
    *
    * The upper 30 bits of this value are reserved, the low two bits contain
    * a value as follows:
    */</font>
#  define PNG_IMAGE_WARNING <font color='#979000'>1</font>
#  define PNG_IMAGE_ERROR <font color='#979000'>2</font>
   <font color='#009900'>/*
    * The result is a two bit code such that a value more than 1 indicates
    * a failure in the API just called:
    *
    *    0 - no warning or error
    *    1 - warning
    *    2 - error
    *    3 - error preceded by warning
    */</font>
#  define <b><a name='PNG_IMAGE_FAILED'></a>PNG_IMAGE_FAILED</b><font face='Lucida Console'>(</font>png_cntrl<font face='Lucida Console'>)</font> <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>png_cntrl<font face='Lucida Console'>)</font>.warning_or_error<font face='Lucida Console'>)</font><font color='#5555FF'>&amp;</font><font color='#979000'>0x03</font><font face='Lucida Console'>)</font><font color='#5555FF'>&gt;</font><font color='#979000'>1</font><font face='Lucida Console'>)</font>

   png_uint_32  warning_or_error;

   <font color='#0000FF'><u>char</u></font>         message[<font color='#979000'>64</font>];
<b>}</b> png_image, <font color='#5555FF'>*</font>png_imagep;

<font color='#009900'>/* The samples of the image have one to four channels whose components have
 * original values in the range 0 to 1.0:
 *
 * 1: A single gray or luminance channel (G).
 * 2: A gray/luminance channel and an alpha channel (GA).
 * 3: Three red, green, blue color channels (RGB).
 * 4: Three color channels and an alpha channel (RGBA).
 *
 * The components are encoded in one of two ways:
 *
 * a) As a small integer, value 0..255, contained in a single byte.  For the
 * alpha channel the original value is simply value/255.  For the color or
 * luminance channels the value is encoded according to the sRGB specification
 * and matches the 8-bit format expected by typical display devices.
 *
 * The color/gray channels are not scaled (pre-multiplied) by the alpha
 * channel and are suitable for passing to color management software.
 *
 * b) As a value in the range 0..65535, contained in a 2-byte integer.  All
 * channels can be converted to the original value by dividing by 65535; all
 * channels are linear.  Color channels use the RGB encoding (RGB end-points) of
 * the sRGB specification.  This encoding is identified by the
 * PNG_FORMAT_FLAG_LINEAR flag below.
 *
 * When the simplified API needs to convert between sRGB and linear colorspaces,
 * the actual sRGB transfer curve defined in the sRGB specification (see the
 * article at http://en.wikipedia.org/wiki/SRGB) is used, not the gamma=1/2.2
 * approximation used elsewhere in libpng.
 *
 * When an alpha channel is present it is expected to denote pixel coverage
 * of the color or luminance channels and is returned as an associated alpha
 * channel: the color/gray channels are scaled (pre-multiplied) by the alpha
 * value.
 *
 * The samples are either contained directly in the image data, between 1 and 8
 * bytes per pixel according to the encoding, or are held in a color-map indexed
 * by bytes in the image data.  In the case of a color-map the color-map entries
 * are individual samples, encoded as above, and the image data has one byte per
 * pixel to select the relevant sample from the color-map.
 */</font>

<font color='#009900'>/* PNG_FORMAT_*
 *
 * #defines to be used in png_image::format.  Each #define identifies a
 * particular layout of sample data and, if present, alpha values.  There are
 * separate defines for each of the two component encodings.
 *
 * A format is built up using single bit flag values.  All combinations are
 * valid.  Formats can be built up from the flag values or you can use one of
 * the predefined values below.  When testing formats always use the FORMAT_FLAG
 * macros to test for individual features - future versions of the library may
 * add new flags.
 *
 * When reading or writing color-mapped images the format should be set to the
 * format of the entries in the color-map then png_image_{read,write}_colormap
 * called to read or write the color-map and set the format correctly for the
 * image data.  Do not set the PNG_FORMAT_FLAG_COLORMAP bit directly!
 *
 * NOTE: libpng can be built with particular features disabled, if you see
 * compiler errors because the definition of one of the following flags has been
 * compiled out it is because libpng does not have the required support.  It is
 * possible, however, for the libpng configuration to enable the format on just
 * read or just write; in that case you may see an error at run time.  You can
 * guard against this by checking for the definition of the appropriate
 * "_SUPPORTED" macro, one of:
 *
 *    PNG_SIMPLIFIED_{READ,WRITE}_{BGR,AFIRST}_SUPPORTED
 */</font>
<font color='#0000FF'>#define</font> PNG_FORMAT_FLAG_ALPHA    <font color='#979000'>0x01U</font> <font color='#009900'>/* format with an alpha channel */</font>
<font color='#0000FF'>#define</font> PNG_FORMAT_FLAG_COLOR    <font color='#979000'>0x02U</font> <font color='#009900'>/* color format: otherwise grayscale */</font>
<font color='#0000FF'>#define</font> PNG_FORMAT_FLAG_LINEAR   <font color='#979000'>0x04U</font> <font color='#009900'>/* 2 byte channels else 1 byte */</font>
<font color='#0000FF'>#define</font> PNG_FORMAT_FLAG_COLORMAP <font color='#979000'>0x08U</font> <font color='#009900'>/* image data is color-mapped */</font>

<font color='#0000FF'>#ifdef</font> PNG_FORMAT_BGR_SUPPORTED
#  define PNG_FORMAT_FLAG_BGR    <font color='#979000'>0x10U</font> <font color='#009900'>/* BGR colors, else order is RGB */</font>
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> PNG_FORMAT_AFIRST_SUPPORTED
#  define PNG_FORMAT_FLAG_AFIRST <font color='#979000'>0x20U</font> <font color='#009900'>/* alpha channel comes first */</font>
<font color='#0000FF'>#endif</font>

<font color='#009900'>/* Commonly used formats have predefined macros.
 *
 * First the single byte (sRGB) formats:
 */</font>
<font color='#0000FF'>#define</font> PNG_FORMAT_GRAY <font color='#979000'>0</font>
<font color='#0000FF'>#define</font> PNG_FORMAT_GA   PNG_FORMAT_FLAG_ALPHA
<font color='#0000FF'>#define</font> PNG_FORMAT_AG   <font face='Lucida Console'>(</font>PNG_FORMAT_GA<font color='#5555FF'>|</font>PNG_FORMAT_FLAG_AFIRST<font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PNG_FORMAT_RGB  PNG_FORMAT_FLAG_COLOR
<font color='#0000FF'>#define</font> PNG_FORMAT_BGR  <font face='Lucida Console'>(</font>PNG_FORMAT_FLAG_COLOR<font color='#5555FF'>|</font>PNG_FORMAT_FLAG_BGR<font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PNG_FORMAT_RGBA <font face='Lucida Console'>(</font>PNG_FORMAT_RGB<font color='#5555FF'>|</font>PNG_FORMAT_FLAG_ALPHA<font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PNG_FORMAT_ARGB <font face='Lucida Console'>(</font>PNG_FORMAT_RGBA<font color='#5555FF'>|</font>PNG_FORMAT_FLAG_AFIRST<font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PNG_FORMAT_BGRA <font face='Lucida Console'>(</font>PNG_FORMAT_BGR<font color='#5555FF'>|</font>PNG_FORMAT_FLAG_ALPHA<font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PNG_FORMAT_ABGR <font face='Lucida Console'>(</font>PNG_FORMAT_BGRA<font color='#5555FF'>|</font>PNG_FORMAT_FLAG_AFIRST<font face='Lucida Console'>)</font>

<font color='#009900'>/* Then the linear 2-byte formats.  When naming these "Y" is used to
 * indicate a luminance (gray) channel.
 */</font>
<font color='#0000FF'>#define</font> PNG_FORMAT_LINEAR_Y PNG_FORMAT_FLAG_LINEAR
<font color='#0000FF'>#define</font> PNG_FORMAT_LINEAR_Y_ALPHA <font face='Lucida Console'>(</font>PNG_FORMAT_FLAG_LINEAR<font color='#5555FF'>|</font>PNG_FORMAT_FLAG_ALPHA<font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PNG_FORMAT_LINEAR_RGB <font face='Lucida Console'>(</font>PNG_FORMAT_FLAG_LINEAR<font color='#5555FF'>|</font>PNG_FORMAT_FLAG_COLOR<font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PNG_FORMAT_LINEAR_RGB_ALPHA \
   <font face='Lucida Console'>(</font>PNG_FORMAT_FLAG_LINEAR<font color='#5555FF'>|</font>PNG_FORMAT_FLAG_COLOR<font color='#5555FF'>|</font>PNG_FORMAT_FLAG_ALPHA<font face='Lucida Console'>)</font>

<font color='#009900'>/* With color-mapped formats the image data is one byte for each pixel, the byte
 * is an index into the color-map which is formatted as above.  To obtain a
 * color-mapped format it is sufficient just to add the PNG_FOMAT_FLAG_COLORMAP
 * to one of the above definitions, or you can use one of the definitions below.
 */</font>
<font color='#0000FF'>#define</font> PNG_FORMAT_RGB_COLORMAP  <font face='Lucida Console'>(</font>PNG_FORMAT_RGB<font color='#5555FF'>|</font>PNG_FORMAT_FLAG_COLORMAP<font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PNG_FORMAT_BGR_COLORMAP  <font face='Lucida Console'>(</font>PNG_FORMAT_BGR<font color='#5555FF'>|</font>PNG_FORMAT_FLAG_COLORMAP<font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PNG_FORMAT_RGBA_COLORMAP <font face='Lucida Console'>(</font>PNG_FORMAT_RGBA<font color='#5555FF'>|</font>PNG_FORMAT_FLAG_COLORMAP<font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PNG_FORMAT_ARGB_COLORMAP <font face='Lucida Console'>(</font>PNG_FORMAT_ARGB<font color='#5555FF'>|</font>PNG_FORMAT_FLAG_COLORMAP<font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PNG_FORMAT_BGRA_COLORMAP <font face='Lucida Console'>(</font>PNG_FORMAT_BGRA<font color='#5555FF'>|</font>PNG_FORMAT_FLAG_COLORMAP<font face='Lucida Console'>)</font>
<font color='#0000FF'>#define</font> PNG_FORMAT_ABGR_COLORMAP <font face='Lucida Console'>(</font>PNG_FORMAT_ABGR<font color='#5555FF'>|</font>PNG_FORMAT_FLAG_COLORMAP<font face='Lucida Console'>)</font>

<font color='#009900'>/* PNG_IMAGE macros
 *
 * These are convenience macros to derive information from a png_image
 * structure.  The PNG_IMAGE_SAMPLE_ macros return values appropriate to the
 * actual image sample values - either the entries in the color-map or the
 * pixels in the image.  The PNG_IMAGE_PIXEL_ macros return corresponding values
 * for the pixels and will always return 1 for color-mapped formats.  The
 * remaining macros return information about the rows in the image and the
 * complete image.
 *
 * NOTE: All the macros that take a png_image::format parameter are compile time
 * constants if the format parameter is, itself, a constant.  Therefore these
 * macros can be used in array declarations and case labels where required.
 * Similarly the macros are also pre-processor constants (sizeof is not used) so
 * they can be used in #if tests.
 *
 * First the information about the samples.
 */</font>
<font color='#0000FF'>#define</font> PNG_IMAGE_SAMPLE_CHANNELS<font face='Lucida Console'>(</font>fmt<font face='Lucida Console'>)</font>\
   <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>fmt<font face='Lucida Console'>)</font><font color='#5555FF'>&amp;</font><font face='Lucida Console'>(</font>PNG_FORMAT_FLAG_COLOR<font color='#5555FF'>|</font>PNG_FORMAT_FLAG_ALPHA<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font><font color='#5555FF'>+</font><font color='#979000'>1</font><font face='Lucida Console'>)</font>
   <font color='#009900'>/* Return the total number of channels in a given format: 1..4 */</font>

<font color='#0000FF'>#define</font> PNG_IMAGE_SAMPLE_COMPONENT_SIZE<font face='Lucida Console'>(</font>fmt<font face='Lucida Console'>)</font>\
   <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>fmt<font face='Lucida Console'>)</font> <font color='#5555FF'>&amp;</font> PNG_FORMAT_FLAG_LINEAR<font face='Lucida Console'>)</font> <font color='#5555FF'>&gt;</font><font color='#5555FF'>&gt;</font> <font color='#979000'>2</font><font face='Lucida Console'>)</font><font color='#5555FF'>+</font><font color='#979000'>1</font><font face='Lucida Console'>)</font>
   <font color='#009900'>/* Return the size in bytes of a single component of a pixel or color-map
    * entry (as appropriate) in the image: 1 or 2.
    */</font>

<font color='#0000FF'>#define</font> PNG_IMAGE_SAMPLE_SIZE<font face='Lucida Console'>(</font>fmt<font face='Lucida Console'>)</font>\
   <font face='Lucida Console'>(</font><font color='#BB00BB'>PNG_IMAGE_SAMPLE_CHANNELS</font><font face='Lucida Console'>(</font>fmt<font face='Lucida Console'>)</font> <font color='#5555FF'>*</font> <font color='#BB00BB'>PNG_IMAGE_SAMPLE_COMPONENT_SIZE</font><font face='Lucida Console'>(</font>fmt<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
   <font color='#009900'>/* This is the size of the sample data for one sample.  If the image is
    * color-mapped it is the size of one color-map entry (and image pixels are
    * one byte in size), otherwise it is the size of one image pixel.
    */</font>

<font color='#0000FF'>#define</font> PNG_IMAGE_MAXIMUM_COLORMAP_COMPONENTS<font face='Lucida Console'>(</font>fmt<font face='Lucida Console'>)</font>\
   <font face='Lucida Console'>(</font><font color='#BB00BB'>PNG_IMAGE_SAMPLE_CHANNELS</font><font face='Lucida Console'>(</font>fmt<font face='Lucida Console'>)</font> <font color='#5555FF'>*</font> <font color='#979000'>256</font><font face='Lucida Console'>)</font>
   <font color='#009900'>/* The maximum size of the color-map required by the format expressed in a
    * count of components.  This can be used to compile-time allocate a
    * color-map:
    *
    * png_uint_16 colormap[PNG_IMAGE_MAXIMUM_COLORMAP_COMPONENTS(linear_fmt)];
    *
    * png_byte colormap[PNG_IMAGE_MAXIMUM_COLORMAP_COMPONENTS(sRGB_fmt)];
    *
    * Alternatively use the PNG_IMAGE_COLORMAP_SIZE macro below to use the
    * information from one of the png_image_begin_read_ APIs and dynamically
    * allocate the required memory.
    */</font>

<font color='#009900'>/* Corresponding information about the pixels */</font>
<font color='#0000FF'>#define</font> PNG_IMAGE_PIXEL_<font face='Lucida Console'>(</font>test,fmt<font face='Lucida Console'>)</font>\
   <font face='Lucida Console'>(</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>fmt<font face='Lucida Console'>)</font><font color='#5555FF'>&amp;</font>PNG_FORMAT_FLAG_COLORMAP<font face='Lucida Console'>)</font>?<font color='#979000'>1</font>:<font color='#BB00BB'>test</font><font face='Lucida Console'>(</font>fmt<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>

<font color='#0000FF'>#define</font> PNG_IMAGE_PIXEL_CHANNELS<font face='Lucida Console'>(</font>fmt<font face='Lucida Console'>)</font>\
   <b><a name='PNG_IMAGE_PIXEL_'></a>PNG_IMAGE_PIXEL_</b><font face='Lucida Console'>(</font>PNG_IMAGE_SAMPLE_CHANNELS,fmt<font face='Lucida Console'>)</font>
   <font color='#009900'>/* The number of separate channels (components) in a pixel; 1 for a
    * color-mapped image.
    */</font>

<font color='#0000FF'>#define</font> PNG_IMAGE_PIXEL_COMPONENT_SIZE<font face='Lucida Console'>(</font>fmt<font face='Lucida Console'>)</font>\
   <b><a name='PNG_IMAGE_PIXEL_'></a>PNG_IMAGE_PIXEL_</b><font face='Lucida Console'>(</font>PNG_IMAGE_SAMPLE_COMPONENT_SIZE,fmt<font face='Lucida Console'>)</font>
   <font color='#009900'>/* The size, in bytes, of each component in a pixel; 1 for a color-mapped
    * image.
    */</font>

<font color='#0000FF'>#define</font> PNG_IMAGE_PIXEL_SIZE<font face='Lucida Console'>(</font>fmt<font face='Lucida Console'>)</font> PNG_IMAGE_PIXEL_<font face='Lucida Console'>(</font>PNG_IMAGE_SAMPLE_SIZE,fmt<font face='Lucida Console'>)</font>
   <font color='#009900'>/* The size, in bytes, of a complete pixel; 1 for a color-mapped image. */</font>

<font color='#009900'>/* Information about the whole row, or whole image */</font>
<font color='#0000FF'>#define</font> PNG_IMAGE_ROW_STRIDE<font face='Lucida Console'>(</font>image<font face='Lucida Console'>)</font>\
   <font face='Lucida Console'>(</font><font color='#BB00BB'>PNG_IMAGE_PIXEL_CHANNELS</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>image<font face='Lucida Console'>)</font>.format<font face='Lucida Console'>)</font> <font color='#5555FF'>*</font> <font face='Lucida Console'>(</font>image<font face='Lucida Console'>)</font>.width<font face='Lucida Console'>)</font>
   <font color='#009900'>/* Return the total number of components in a single row of the image; this
    * is the minimum 'row stride', the minimum count of components between each
    * row.  For a color-mapped image this is the minimum number of bytes in a
    * row.
    */</font>

<font color='#0000FF'>#define</font> PNG_IMAGE_BUFFER_SIZE<font face='Lucida Console'>(</font>image, row_stride<font face='Lucida Console'>)</font>\
   <font face='Lucida Console'>(</font><font color='#BB00BB'>PNG_IMAGE_PIXEL_COMPONENT_SIZE</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>image<font face='Lucida Console'>)</font>.format<font face='Lucida Console'>)</font><font color='#5555FF'>*</font><font face='Lucida Console'>(</font>image<font face='Lucida Console'>)</font>.height<font color='#5555FF'>*</font><font face='Lucida Console'>(</font>row_stride<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
   <font color='#009900'>/* Return the size, in bytes, of an image buffer given a png_image and a row
    * stride - the number of components to leave space for in each row.
    */</font>

<font color='#0000FF'>#define</font> PNG_IMAGE_SIZE<font face='Lucida Console'>(</font>image<font face='Lucida Console'>)</font>\
   <b><a name='PNG_IMAGE_BUFFER_SIZE'></a>PNG_IMAGE_BUFFER_SIZE</b><font face='Lucida Console'>(</font>image, <font color='#BB00BB'>PNG_IMAGE_ROW_STRIDE</font><font face='Lucida Console'>(</font>image<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>
   <font color='#009900'>/* Return the size, in bytes, of the image in memory given just a png_image;
    * the row stride is the minimum stride required for the image.
    */</font>

<font color='#0000FF'>#define</font> PNG_IMAGE_COLORMAP_SIZE<font face='Lucida Console'>(</font>image<font face='Lucida Console'>)</font>\
   <font face='Lucida Console'>(</font><font color='#BB00BB'>PNG_IMAGE_SAMPLE_SIZE</font><font face='Lucida Console'>(</font><font face='Lucida Console'>(</font>image<font face='Lucida Console'>)</font>.format<font face='Lucida Console'>)</font> <font color='#5555FF'>*</font> <font face='Lucida Console'>(</font>image<font face='Lucida Console'>)</font>.colormap_entries<font face='Lucida Console'>)</font>
   <font color='#009900'>/* Return the size, in bytes, of the color-map of this image.  If the image
    * format is not a color-map format this will return a size sufficient for
    * 256 entries in the given format; check PNG_FORMAT_FLAG_COLORMAP if
    * you don't want to allocate a color-map in this case.
    */</font>

<font color='#009900'>/* PNG_IMAGE_FLAG_*
 *
 * Flags containing additional information about the image are held in the
 * 'flags' field of png_image.
 */</font>
<font color='#0000FF'>#define</font> PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB <font color='#979000'>0x01</font>
   <font color='#009900'>/* This indicates the the RGB values of the in-memory bitmap do not
    * correspond to the red, green and blue end-points defined by sRGB.
    */</font>

<font color='#0000FF'>#define</font> PNG_IMAGE_FLAG_FAST <font color='#979000'>0x02</font>
   <font color='#009900'>/* On write emphasise speed over compression; the resultant PNG file will be
    * larger but will be produced significantly faster, particular for large
    * images.  Do not use this option for images which will be distributed, only
    * used it when producing intermediate files that will be read back in
    * repeatedly.  For a typical 24-bit image the option will double the read
    * speed at the cost of increasing the image size by 25%, however for many
    * more compressible images the PNG file can be 10 times larger with only a
    * slight speed gain.
    */</font>

<font color='#0000FF'>#define</font> PNG_IMAGE_FLAG_16BIT_sRGB <font color='#979000'>0x04</font>
   <font color='#009900'>/* On read if the image is a 16-bit per component image and there is no gAMA
    * or sRGB chunk assume that the components are sRGB encoded.  Notice that
    * images output by the simplified API always have gamma information; setting
    * this flag only affects the interpretation of 16-bit images from an
    * external source.  It is recommended that the application expose this flag
    * to the user; the user can normally easily recognize the difference between
    * linear and sRGB encoding.  This flag has no effect on write - the data
    * passed to the write APIs must have the correct encoding (as defined
    * above.)
    *
    * If the flag is not set (the default) input 16-bit per component data is
    * assumed to be linear.
    *
    * NOTE: the flag can only be set after the png_image_begin_read_ call,
    * because that call initializes the 'flags' field.
    */</font>

<font color='#0000FF'>#ifdef</font> PNG_SIMPLIFIED_READ_SUPPORTED
<font color='#009900'>/* READ APIs
 * ---------
 *
 * The png_image passed to the read APIs must have been initialized by setting
 * the png_controlp field 'opaque' to NULL (or, safer, memset the whole thing.)
 */</font>
<font color='#0000FF'>#ifdef</font> PNG_STDIO_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>234</font>, <font color='#0000FF'><u>int</u></font>, png_image_begin_read_from_file, <font face='Lucida Console'>(</font>png_imagep image,
   <font color='#0000FF'>const</font> <font color='#0000FF'><u>char</u></font> <font color='#5555FF'>*</font>file_name<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
   <font color='#009900'>/* The named file is opened for read and the image header is filled in
    * from the PNG header in the file.
    */</font>

<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>235</font>, <font color='#0000FF'><u>int</u></font>, png_image_begin_read_from_stdio, <font face='Lucida Console'>(</font>png_imagep image,
   FILE<font color='#5555FF'>*</font> file<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
   <font color='#009900'>/* The PNG header is read from the stdio FILE object. */</font>
<font color='#0000FF'>#endif</font> <font color='#009900'>/* PNG_STDIO_SUPPORTED */</font>

<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>236</font>, <font color='#0000FF'><u>int</u></font>, png_image_begin_read_from_memory, <font face='Lucida Console'>(</font>png_imagep image,
   png_const_voidp memory, png_size_t size<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
   <font color='#009900'>/* The PNG header is read from the given memory buffer. */</font>

<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>237</font>, <font color='#0000FF'><u>int</u></font>, png_image_finish_read, <font face='Lucida Console'>(</font>png_imagep image,
   png_const_colorp background, <font color='#0000FF'><u>void</u></font> <font color='#5555FF'>*</font>buffer, png_int_32 row_stride,
   <font color='#0000FF'><u>void</u></font> <font color='#5555FF'>*</font>colormap<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
   <font color='#009900'>/* Finish reading the image into the supplied buffer and clean up the
    * png_image structure.
    *
    * row_stride is the step, in byte or 2-byte units as appropriate,
    * between adjacent rows.  A positive stride indicates that the top-most row
    * is first in the buffer - the normal top-down arrangement.  A negative
    * stride indicates that the bottom-most row is first in the buffer.
    *
    * background need only be supplied if an alpha channel must be removed from
    * a png_byte format and the removal is to be done by compositing on a solid
    * color; otherwise it may be NULL and any composition will be done directly
    * onto the buffer.  The value is an sRGB color to use for the background,
    * for grayscale output the green channel is used.
    *
    * background must be supplied when an alpha channel must be removed from a
    * single byte color-mapped output format, in other words if:
    *
    * 1) The original format from png_image_begin_read_from_* had
    *    PNG_FORMAT_FLAG_ALPHA set.
    * 2) The format set by the application does not.
    * 3) The format set by the application has PNG_FORMAT_FLAG_COLORMAP set and
    *    PNG_FORMAT_FLAG_LINEAR *not* set.
    *
    * For linear output removing the alpha channel is always done by compositing
    * on black and background is ignored.
    *
    * colormap must be supplied when PNG_FORMAT_FLAG_COLORMAP is set.  It must
    * be at least the size (in bytes) returned by PNG_IMAGE_COLORMAP_SIZE.
    * image-&gt;colormap_entries will be updated to the actual number of entries
    * written to the colormap; this may be less than the original value.
    */</font>

<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>238</font>, <font color='#0000FF'><u>void</u></font>, png_image_free, <font face='Lucida Console'>(</font>png_imagep image<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
   <font color='#009900'>/* Free any data allocated by libpng in image-&gt;opaque, setting the pointer to
    * NULL.  May be called at any time after the structure is initialized.
    */</font>
<font color='#0000FF'>#endif</font> <font color='#009900'>/* PNG_SIMPLIFIED_READ_SUPPORTED */</font>

<font color='#0000FF'>#ifdef</font> PNG_SIMPLIFIED_WRITE_SUPPORTED
<font color='#0000FF'>#ifdef</font> PNG_STDIO_SUPPORTED
<font color='#009900'>/* WRITE APIS
 * ----------
 * For write you must initialize a png_image structure to describe the image to
 * be written.  To do this use memset to set the whole structure to 0 then
 * initialize fields describing your image.
 *
 * version: must be set to PNG_IMAGE_VERSION
 * opaque: must be initialized to NULL
 * width: image width in pixels
 * height: image height in rows
 * format: the format of the data (image and color-map) you wish to write
 * flags: set to 0 unless one of the defined flags applies; set
 *    PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB for color format images where the RGB
 *    values do not correspond to the colors in sRGB.
 * colormap_entries: set to the number of entries in the color-map (0 to 256)
 */</font>
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>239</font>, <font color='#0000FF'><u>int</u></font>, png_image_write_to_file, <font face='Lucida Console'>(</font>png_imagep image,
   <font color='#0000FF'>const</font> <font color='#0000FF'><u>char</u></font> <font color='#5555FF'>*</font>file, <font color='#0000FF'><u>int</u></font> convert_to_8bit, <font color='#0000FF'>const</font> <font color='#0000FF'><u>void</u></font> <font color='#5555FF'>*</font>buffer,
   png_int_32 row_stride, <font color='#0000FF'>const</font> <font color='#0000FF'><u>void</u></font> <font color='#5555FF'>*</font>colormap<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
   <font color='#009900'>/* Write the image to the named file. */</font>

<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>240</font>, <font color='#0000FF'><u>int</u></font>, png_image_write_to_stdio, <font face='Lucida Console'>(</font>png_imagep image, FILE <font color='#5555FF'>*</font>file,
   <font color='#0000FF'><u>int</u></font> convert_to_8_bit, <font color='#0000FF'>const</font> <font color='#0000FF'><u>void</u></font> <font color='#5555FF'>*</font>buffer, png_int_32 row_stride,
   <font color='#0000FF'>const</font> <font color='#0000FF'><u>void</u></font> <font color='#5555FF'>*</font>colormap<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
   <font color='#009900'>/* Write the image to the given (FILE*). */</font>

<font color='#009900'>/* With both write APIs if image is in one of the linear formats with 16-bit
 * data then setting convert_to_8_bit will cause the output to be an 8-bit PNG
 * gamma encoded according to the sRGB specification, otherwise a 16-bit linear
 * encoded PNG file is written.
 *
 * With color-mapped data formats the colormap parameter point to a color-map
 * with at least image-&gt;colormap_entries encoded in the specified format.  If
 * the format is linear the written PNG color-map will be converted to sRGB
 * regardless of the convert_to_8_bit flag.
 *
 * With all APIs row_stride is handled as in the read APIs - it is the spacing
 * from one row to the next in component sized units (1 or 2 bytes) and if
 * negative indicates a bottom-up row layout in the buffer.
 *
 * Note that the write API does not support interlacing or sub-8-bit pixels.
 */</font>
<font color='#0000FF'>#endif</font> <font color='#009900'>/* PNG_STDIO_SUPPORTED */</font>
<font color='#0000FF'>#endif</font> <font color='#009900'>/* PNG_SIMPLIFIED_WRITE_SUPPORTED */</font>
<font color='#009900'>/*******************************************************************************
 *  END OF SIMPLIFIED API
 ******************************************************************************/</font>

<font color='#0000FF'>#ifdef</font> PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>242</font>, <font color='#0000FF'><u>void</u></font>, png_set_check_for_invalid_index,
    <font face='Lucida Console'>(</font>png_structrp png_ptr, <font color='#0000FF'><u>int</u></font> allowed<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
#  ifdef PNG_GET_PALETTE_MAX_SUPPORTED
<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>243</font>, <font color='#0000FF'><u>int</u></font>, png_get_palette_max, <font face='Lucida Console'>(</font>png_const_structp png_ptr,
    png_const_infop info_ptr<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
#  endif
<font color='#0000FF'>#endif</font> <font color='#009900'>/* CHECK_FOR_INVALID_INDEX */</font>

<font color='#009900'>/*******************************************************************************
 *  IMPLEMENTATION OPTIONS
 *******************************************************************************
 *
 * Support for arbitrary implementation-specific optimizations.  The API allows
 * particular options to be turned on or off.  'Option' is the number of the
 * option and 'onoff' is 0 (off) or non-0 (on).  The value returned is given
 * by the PNG_OPTION_ defines below.
 *
 * HARDWARE: normally hardware capabilites, such as the Intel SSE instructions,
 *           are detected at run time, however sometimes it may be impossible
 *           to do this in user mode, in which case it is necessary to discover
 *           the capabilities in an OS specific way.  Such capabilities are
 *           listed here when libpng has support for them and must be turned
 *           ON by the application if present.
 *
 * SOFTWARE: sometimes software optimizations actually result in performance
 *           decrease on some architectures or systems, or with some sets of
 *           PNG images.  'Software' options allow such optimizations to be
 *           selected at run time.
 */</font>
<font color='#0000FF'>#ifdef</font> PNG_SET_OPTION_SUPPORTED
<font color='#0000FF'>#ifdef</font> PNG_ARM_NEON_API_SUPPORTED
#  define PNG_ARM_NEON   <font color='#979000'>0</font> <font color='#009900'>/* HARDWARE: ARM Neon SIMD instructions supported */</font>
<font color='#0000FF'>#endif</font>
<font color='#0000FF'>#define</font> PNG_MAXIMUM_INFLATE_WINDOW <font color='#979000'>2</font> <font color='#009900'>/* SOFTWARE: force maximum window */</font>
<font color='#0000FF'>#define</font> PNG_OPTION_NEXT  <font color='#979000'>4</font> <font color='#009900'>/* Next option - numbers must be even */</font>

<font color='#009900'>/* Return values: NOTE: there are four values and 'off' is *not* zero */</font>
<font color='#0000FF'>#define</font> PNG_OPTION_UNSET   <font color='#979000'>0</font> <font color='#009900'>/* Unset - defaults to off */</font>
<font color='#0000FF'>#define</font> PNG_OPTION_INVALID <font color='#979000'>1</font> <font color='#009900'>/* Option number out of range */</font>
<font color='#0000FF'>#define</font> PNG_OPTION_OFF     <font color='#979000'>2</font>
<font color='#0000FF'>#define</font> PNG_OPTION_ON      <font color='#979000'>3</font>

<b><a name='PNG_EXPORT'></a>PNG_EXPORT</b><font face='Lucida Console'>(</font><font color='#979000'>244</font>, <font color='#0000FF'><u>int</u></font>, png_set_option, <font face='Lucida Console'>(</font>png_structrp png_ptr, <font color='#0000FF'><u>int</u></font> option,
   <font color='#0000FF'><u>int</u></font> onoff<font face='Lucida Console'>)</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#009900'>/*******************************************************************************
 *  END OF HARDWARE OPTIONS
 ******************************************************************************/</font>

<font color='#009900'>/* Maintainer: Put new public prototypes here ^, in libpng.3, and project
 * defs, scripts/pnglibconf.h, and scripts/pnglibconf.h.prebuilt
 */</font>

<font color='#009900'>/* The last ordinal number (this is the *last* one already used; the next
 * one to use is one more than this.)  Maintainer, remember to add an entry to
 * scripts/symbols.def as well.
 */</font>
<font color='#0000FF'>#ifdef</font> PNG_EXPORT_LAST_ORDINAL
  <b><a name='PNG_EXPORT_LAST_ORDINAL'></a>PNG_EXPORT_LAST_ORDINAL</b><font face='Lucida Console'>(</font><font color='#979000'>244</font><font face='Lucida Console'>)</font>;
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#ifdef</font> __cplusplus
<b>}</b>
<font color='#0000FF'>#endif</font>

<font color='#0000FF'>#endif</font> <font color='#009900'>/* PNG_VERSION_INFO_ONLY */</font>
<font color='#009900'>/* Do not put anything past this line */</font>
<font color='#0000FF'>#endif</font> <font color='#009900'>/* PNG_H */</font>

</pre></body></html>