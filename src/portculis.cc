//  ********************************************************************
//  This file is part of Portculis.
//
//  Portculis is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  Portculis is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with Portculis.  If not, see <http://www.gnu.org/licenses/>.
//  *******************************************************************

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <string.h>
#include <iostream>
#include <fstream>

#include <seqan/bam_io.h>
#include <seqan/sequence.h>
#include <seqan/stream.h>

#include <boost/filesystem.hpp>
#include <boost/program_options.hpp>

#include "portculis.hpp"

using std::string;
using std::cout;
using std::cerr;
using std::endl;
using std::exception;

namespace po = boost::program_options;


// Default values for arguments
const string DEFAULT_OUTPUT_PREFIX = "portculis_out";
const uint16_t DEFAULT_THREADS = 4;
const uint32_t DEFAULT_CHUNK_SIZE_PER_THREAD = 10000;
const uint32_t DEFAULT_GAP_SIZE = 100;

/**
 * Start point for portculis.
 */
int main(int argc, char *argv[])
{
    try
    {
        // Portculis args
        string bam_file;
        string genome_file;
        string output_prefix;
        uint16_t threads;
        bool disable_threaded_io;
        uint32_t chunk_size_per_thread;
        uint32_t gap_size;
        bool verbose;

        // Declare the supported options.
        po::options_description generic_options("Portculis Help.\nUsage: portculis [options] <bam-file> <genome-file>\nAllowed options");
        generic_options.add_options()
                ("help", "Produce help message")
                ("version", "Print version string")
                ("verbose,v", "Print extra information")
                ("output_prefix,o", po::value<string>(&output_prefix)->default_value(DEFAULT_OUTPUT_PREFIX), "Path prefix for files generated by this program.")
                ("threads,t", po::value<uint16_t>(&threads)->default_value(DEFAULT_THREADS), "The number of threads to use.")
                ("disable_threaded_io", po::value<bool>(&disable_threaded_io)->default_value(false), "Whether to acquire data in parallel to processing.")
                ("chunk_size_per_thread,c", po::value<uint32_t>(&chunk_size_per_thread)->default_value(DEFAULT_CHUNK_SIZE_PER_THREAD), "The number of BAM alignment records to process per chunk per thread.  Note that memory usage will scale with the values set here and with the number of threads chosen.")
                ("gap,g", po::value<uint32_t>(&gap_size)->default_value(DEFAULT_GAP_SIZE), "The minimum gap size between adjacent alignments that determines whether or not we can chunk the data at this point.")
                ;

        // Hidden options, will be allowed both on command line and
        // in config file, but will not be shown to the user.
        po::options_description hidden_options("Hidden options");
        hidden_options.add_options()
                ("bam-file,i", po::value<string>(&bam_file), "Path to the BAM file to process.")
                ("genome-file,i", po::value<string>(&genome_file), "Path to the genome file to process.")
                ;

        // Positional option for the input bam file
        po::positional_options_description p;
        p.add("bam-file", 1);
        p.add("genome-file", 2);

        // Combine non-positional options
        po::options_description cmdline_options;
        cmdline_options.add(generic_options).add(hidden_options);

        // Parse command line
        po::variables_map vm;
        po::store(po::command_line_parser(argc, argv).options(cmdline_options).positional(p).run(), vm);
        po::notify(vm);

        // Output help information the exit if requested
        if (vm.count("help"))
        {
            cout << generic_options << "\n";
            return 1;
        }

        // Output version information then exit if requested
        if (vm.count("version"))
        {
#ifndef PACKAGE_NAME
#define PACKAGE_NAME "Portculis"
#endif

#ifndef PACKAGE_VERSION
#define PACKAGE_VERSION "0.1.0"
#endif
            cout << PACKAGE_NAME << " V" << PACKAGE_VERSION << "\n";
            return 0;
        }

        // Acquire path to bam file
        if (vm.count("bam-file"))
        {
            bam_file = vm["bam-file"].as<string>();
        }

        // Acquire path to genome file
        if (vm.count("genome-file"))
        {
            genome_file = vm["genome-file"].as<string>();
        }

        // Print configuration information if in verbose mode
        if (vm.count("verbose"))
        {
            verbose = true;

            cerr << "Portculis settings: " << endl
                    << " Input bam file: " << bam_file << endl
                    << " Output prefix: " << output_prefix << endl
                    << " Worker threads: " << threads << endl
                    << " Use threaded IO: " << !disable_threaded_io << endl
                    << " Chunk size per thread: " << chunk_size_per_thread << endl
                    << " Minimum gap size: " << gap_size << endl;
        }


        // Test bam file exists
        if (!boost::filesystem::exists(bam_file))
        {
            cerr << "ERROR: Specified BAM file " << bam_file << " does not exist!" << endl;
            return 2;
        }

        // Test bam file exists
        if (!boost::filesystem::exists(genome_file))
        {
            cerr << "ERROR: Specified genome file " << genome_file << " does not exist!" << endl;
            return 2;
        }


        // Ok we're good to go!

        //Portculis instance(bam_file, genome_file, output_prefix, threads, !disable_threaded_io, chunk_size_per_thread, gap_size, verbose);
        portculis::Portculis instance;
        instance.process();

    }
    catch (exception& e)
    {
        cerr << "Error: " << e.what() << endl;
        return 3;
    }
    catch (const char* msg)
    {
        cerr << "Error: " << msg << endl;
        return 3;
    }
    catch (...)
    {
        cerr << "Error: Exception of unknown type!" << endl;
        return 4;
    }

    return 0;
}

